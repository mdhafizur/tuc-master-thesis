[
  {
    "id": "owasp_bench_sql_concat",
    "name": "SQL Injection - SQL injection via string concatenation (OWASP Benchmark)",
    "code": "// OWASP Benchmark: SQL injection via concatenation\nconst sqlite3 = require('sqlite3').verbose();\n\nfunction searchProducts(searchTerm) {\n    const db = new sqlite3.Database('products.db');\n    \n    // Vulnerable: Direct string concatenation\n    const query = \"SELECT * FROM products WHERE name LIKE '%\" + searchTerm + \"%'\";\n    \n    return new Promise((resolve, reject) => {\n        db.all(query, [], (err, rows) => {\n            if (err) reject(err);\n            else resolve(rows);\n        });\n    });\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "SQL Injection",
        "cwe": "CWE-89",
        "severity": "high",
        "description": "SQL injection via string concatenation (OWASP Benchmark)"
      }
    ],
    "expectedFix": "Use parameterized SQL queries or prepared statements.",
    "metadata": {
      "sourceDataset": "benchmark",
      "sourcePolicy": "external-only",
      "source": "OWASP Benchmark SQL-01",
      "originalId": "owasp_bench_sql_concat",
      "vulnerableLines": [
        7
      ]
    }
  },
  {
    "id": "owasp_bench_sql_template",
    "name": "SQL Injection - SQL injection via template literals (OWASP Benchmark)",
    "code": "// OWASP Benchmark: SQL injection via template literals\nconst mysql = require('mysql');\n\nfunction loginUser(username, password) {\n    const connection = mysql.createConnection(dbConfig);\n    \n    // Vulnerable: Template literal without escaping\n    const sql = `SELECT id, role FROM users WHERE username='${username}' AND password='${password}'`;\n    \n    return new Promise((resolve, reject) => {\n        connection.query(sql, (error, results) => {\n            if (error) reject(error);\n            resolve(results[0] || null);\n        });\n    });\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "SQL Injection",
        "cwe": "CWE-89",
        "severity": "high",
        "description": "SQL injection via template literals (OWASP Benchmark)"
      }
    ],
    "expectedFix": "Use parameterized SQL queries or prepared statements.",
    "metadata": {
      "sourceDataset": "benchmark",
      "sourcePolicy": "external-only",
      "source": "OWASP Benchmark SQL-02",
      "originalId": "owasp_bench_sql_template",
      "vulnerableLines": [
        7
      ]
    }
  },
  {
    "id": "owasp_bench_xss_innerHTML",
    "name": "Cross-Site Scripting (XSS) - XSS via innerHTML assignment (OWASP Benchmark)",
    "code": "// OWASP Benchmark: XSS via innerHTML\nfunction displayUserProfile(userName, userBio) {\n    const profileContainer = document.getElementById('profileContainer');\n    \n    // Vulnerable: Unescaped template literal in innerHTML\n    const profileHtml = `\n        <div class=\"profile\">\n            <h2>Profile: ${userName}</h2>\n            <div class=\"bio\">${userBio}</div>\n        </div>\n    `;\n    \n    profileContainer.innerHTML = profileHtml;\n}\n\nfunction showAlert(message) {\n    // Vulnerable: Direct innerHTML assignment\n    document.getElementById('alerts').innerHTML = \"<div class='alert'>\" + message + \"</div>\";\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Cross-Site Scripting (XSS)",
        "cwe": "CWE-79",
        "severity": "high",
        "description": "XSS via innerHTML assignment (OWASP Benchmark)"
      }
    ],
    "expectedFix": "Escape/sanitize untrusted content and avoid unsafe DOM sinks.",
    "metadata": {
      "sourceDataset": "benchmark",
      "sourcePolicy": "external-only",
      "source": "OWASP Benchmark XSS-01",
      "originalId": "owasp_bench_xss_innerHTML",
      "vulnerableLines": [
        11,
        16
      ]
    }
  },
  {
    "id": "owasp_bench_xss_document_write",
    "name": "Cross-Site Scripting (XSS) - XSS via document.write (OWASP Benchmark)",
    "code": "// OWASP Benchmark: XSS via document.write\nfunction renderPage(title, content) {\n    // Vulnerable: Unescaped content in document.write\n    document.write(`\n        <html>\n            <head><title>${title}</title></head>\n            <body>\n                <h1>${title}</h1>\n                <div>${content}</div>\n            </body>\n        </html>\n    `);\n}\n\nfunction insertScript(scriptContent) {\n    // Vulnerable: Direct script injection\n    document.write(\"<script>\" + scriptContent + \"</script>\");\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Cross-Site Scripting (XSS)",
        "cwe": "CWE-79",
        "severity": "high",
        "description": "XSS via document.write (OWASP Benchmark)"
      }
    ],
    "expectedFix": "Escape/sanitize untrusted content and avoid unsafe DOM sinks.",
    "metadata": {
      "sourceDataset": "benchmark",
      "sourcePolicy": "external-only",
      "source": "OWASP Benchmark XSS-02",
      "originalId": "owasp_bench_xss_document_write",
      "vulnerableLines": [
        3,
        15
      ]
    }
  },
  {
    "id": "owasp_bench_cmd_exec",
    "name": "Command Injection - Command injection via exec (OWASP Benchmark)",
    "code": "// OWASP Benchmark: Command injection\nconst { exec } = require('child_process');\n\nfunction analyzeFile(filename) {\n    // Vulnerable: Unvalidated filename in command\n    const command = `file ${filename}`;\n    \n    return new Promise((resolve, reject) => {\n        exec(command, (error, stdout, stderr) => {\n            if (error) reject(error);\n            else resolve(stdout);\n        });\n    });\n}\n\nfunction compressFile(inputFile, outputFile) {\n    // Vulnerable: Multiple injection points\n    exec(`gzip -c ${inputFile} > ${outputFile}`, (error, stdout) => {\n        console.log('Compression complete');\n    });\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Command Injection",
        "cwe": "CWE-78",
        "severity": "high",
        "description": "Command injection via exec (OWASP Benchmark)"
      }
    ],
    "expectedFix": "Use safe process APIs and never concatenate untrusted input into commands.",
    "metadata": {
      "sourceDataset": "benchmark",
      "sourcePolicy": "external-only",
      "source": "OWASP Benchmark CMD-01",
      "originalId": "owasp_bench_cmd_exec",
      "vulnerableLines": [
        6,
        16
      ]
    }
  },
  {
    "id": "owasp_bench_path_traversal",
    "name": "Path Traversal - Path traversal in file serving (OWASP Benchmark)",
    "code": "// OWASP Benchmark: Path traversal\nconst fs = require('fs');\nconst express = require('express');\nconst app = express();\n\napp.get('/files/:filename', (req, res) => {\n    const filename = req.params.filename;\n    \n    // Vulnerable: No path validation\n    const filepath = './uploads/' + filename;\n    \n    try {\n        const content = fs.readFileSync(filepath, 'utf8');\n        res.send(content);\n    } catch (error) {\n        res.status(404).send('File not found');\n    }\n});\n\nfunction readConfigFile(configName) {\n    // Vulnerable: Path traversal in config reading\n    const configPath = './config/' + configName + '.json';\n    return JSON.parse(fs.readFileSync(configPath, 'utf8'));\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Path Traversal",
        "cwe": "CWE-22",
        "severity": "high",
        "description": "Path traversal in file serving (OWASP Benchmark)"
      }
    ],
    "expectedFix": "Canonicalize paths and restrict access to approved directories.",
    "metadata": {
      "sourceDataset": "benchmark",
      "sourcePolicy": "external-only",
      "source": "OWASP Benchmark PATH-01",
      "originalId": "owasp_bench_path_traversal",
      "vulnerableLines": [
        9,
        20
      ]
    }
  },
  {
    "id": "owasp_bench_weak_crypto",
    "name": "Weak Cryptography - Weak cryptographic algorithms (OWASP Benchmark)",
    "code": "// OWASP Benchmark: Weak cryptography\nconst crypto = require('crypto');\n\nfunction hashPassword(password) {\n    // Vulnerable: Using weak MD5 algorithm\n    return crypto.createHash('md5').update(password).digest('hex');\n}\n\nfunction encryptData(data, key) {\n    // Vulnerable: Using DES encryption\n    const cipher = crypto.createCipher('des', key);\n    let encrypted = cipher.update(data, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    return encrypted;\n}\n\nfunction generateToken() {\n    // Vulnerable: Weak random number generation\n    return Math.random().toString(36).substring(2, 15);\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Weak Cryptography",
        "cwe": "CWE-327",
        "severity": "medium",
        "description": "Weak cryptographic algorithms (OWASP Benchmark)"
      }
    ],
    "expectedFix": "Use strong algorithms and secure key generation/management.",
    "metadata": {
      "sourceDataset": "benchmark",
      "sourcePolicy": "external-only",
      "source": "OWASP Benchmark CRYPTO-01",
      "originalId": "owasp_bench_weak_crypto",
      "vulnerableLines": [
        5,
        10,
        17
      ]
    }
  },
  {
    "id": "owasp_bench_ldap_injection",
    "name": "LDAP Injection - LDAP injection vulnerability (OWASP Benchmark)",
    "code": "// OWASP Benchmark: LDAP injection\nconst ldap = require('ldapjs');\n\nfunction authenticateUser(username, password) {\n    const client = ldap.createClient({\n        url: 'ldap://localhost:389'\n    });\n    \n    // Vulnerable: Unescaped LDAP filter\n    const filter = `(&(uid=${username})(userPassword=${password}))`;\n    \n    const searchOptions = {\n        filter: filter,\n        scope: 'sub'\n    };\n    \n    client.search('dc=example,dc=com', searchOptions, (err, result) => {\n        if (err) throw err;\n        // Process results\n    });\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "LDAP Injection",
        "cwe": "CWE-90",
        "severity": "high",
        "description": "LDAP injection vulnerability (OWASP Benchmark)"
      }
    ],
    "expectedFix": "Use parameterized LDAP queries and sanitize user-controlled input.",
    "metadata": {
      "sourceDataset": "benchmark",
      "sourcePolicy": "external-only",
      "source": "OWASP Benchmark LDAP-01",
      "originalId": "owasp_bench_ldap_injection",
      "vulnerableLines": [
        10
      ]
    }
  },
  {
    "id": "owasp_bench_header_injection",
    "name": "Header Injection - HTTP header injection (OWASP Benchmark)",
    "code": "// OWASP Benchmark: HTTP header injection\nconst express = require('express');\nconst app = express();\n\napp.get('/redirect', (req, res) => {\n    const target = req.query.url;\n    \n    // Vulnerable: Unvalidated redirect URL\n    res.redirect(target);\n});\n\napp.get('/cookie', (req, res) => {\n    const value = req.query.value;\n    \n    // Vulnerable: Unvalidated cookie value\n    res.setHeader('Set-Cookie', `userdata=${value}`);\n    res.send('Cookie set');\n});\n\nfunction setCustomHeader(response, headerValue) {\n    // Vulnerable: Header injection\n    response.setHeader('X-Custom-Header', headerValue);\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Header Injection",
        "cwe": "CWE-113",
        "severity": "medium",
        "description": "HTTP header injection (OWASP Benchmark)"
      }
    ],
    "expectedFix": "Sanitize header values and enforce strict header construction.",
    "metadata": {
      "sourceDataset": "benchmark",
      "sourcePolicy": "external-only",
      "source": "OWASP Benchmark HEADER-01",
      "originalId": "owasp_bench_header_injection",
      "vulnerableLines": [
        8,
        15,
        21
      ]
    }
  },
  {
    "id": "nodejs_cve_2021_23337",
    "name": "Prototype Pollution - Prototype pollution in lodash merge function",
    "code": "// CVE-2021-23337: Prototype pollution in lodash\nconst _ = require('lodash');\n\nfunction mergeUserSettings(defaultSettings, userPreferences) {\n    // Vulnerable: lodash.merge susceptible to prototype pollution\n    return _.merge({}, defaultSettings, userPreferences);\n}\n\nfunction updateUserConfig(userId, configData) {\n    const defaults = {\n        theme: 'light',\n        notifications: true,\n        language: 'en'\n    };\n    \n    // Parse user input (potentially malicious)\n    const userConfig = JSON.parse(configData);\n    \n    // This can pollute Object.prototype if userConfig contains __proto__\n    const mergedConfig = mergeUserSettings(defaults, userConfig);\n    \n    return mergedConfig;\n}\n\n// Attack payload example:\n// {\"__proto__\": {\"polluted\": true}}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Prototype Pollution",
        "cwe": "CWE-1321",
        "severity": "high",
        "description": "Prototype pollution in lodash merge function"
      }
    ],
    "expectedFix": "Block dangerous keys and clone/validate objects before merge operations.",
    "metadata": {
      "sourceDataset": "benchmark",
      "sourcePolicy": "external-only",
      "source": "CVE-2021-23337",
      "originalId": "nodejs_cve_2021_23337",
      "vulnerableLines": [
        5
      ]
    }
  },
  {
    "id": "nodejs_cve_2022_24999",
    "name": "Path Traversal - Path traversal in express static file serving",
    "code": "// CVE-2022-24999: Path traversal in express static\nconst express = require('express');\nconst path = require('path');\nconst fs = require('fs');\n\nconst app = express();\n\n// Vulnerable static file serving implementation\napp.get('/files/:filename', (req, res) => {\n    const filename = req.params.filename;\n    const filePath = path.join(__dirname, 'public', filename);\n    \n    // Vulnerable: No validation of path traversal\n    if (fs.existsSync(filePath)) {\n        res.sendFile(filePath);\n    } else {\n        res.status(404).send('File not found');\n    }\n});\n\n// Attack example: GET /files/../../../etc/passwd",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Path Traversal",
        "cwe": "CWE-22",
        "severity": "high",
        "description": "Path traversal in express static file serving"
      }
    ],
    "expectedFix": "Canonicalize paths and restrict access to approved directories.",
    "metadata": {
      "sourceDataset": "benchmark",
      "sourcePolicy": "external-only",
      "source": "CVE-2022-24999",
      "originalId": "nodejs_cve_2022_24999",
      "vulnerableLines": [
        10
      ]
    }
  },
  {
    "id": "real_world_express_cve_2022_24999",
    "name": "Path Traversal - Real CVE-2022-24999 vulnerability in express",
    "code": "// Real CVE-2022-24999 in Express.js\nconst path = require('path');\nconst fs = require('fs');\n\n// Vulnerable implementation from Express\nfunction sendFile(req, res, options) {\n    const filePath = req.params.path;\n    const root = options.root || './public';\n    \n    // VULNERABILITY: Insufficient path traversal protection\n    const fullPath = path.resolve(root, filePath);\n    \n    if (fs.existsSync(fullPath)) {\n        res.sendFile(fullPath);\n    } else {\n        res.status(404).send('File not found');\n    }\n}\n\n// Attack: GET /files/../../../../etc/passwd",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Path Traversal",
        "cwe": "CWE-22",
        "severity": "high",
        "description": "Real CVE-2022-24999 vulnerability in express"
      }
    ],
    "expectedFix": "Canonicalize paths and restrict access to approved directories.",
    "metadata": {
      "sourceDataset": "real-world",
      "sourcePolicy": "external-only",
      "source": "express - CVE-2022-24999",
      "originalId": "real_world_express_cve_2022_24999",
      "vulnerableLines": [
        8,
        9
      ]
    }
  },
  {
    "id": "real_world_lodash_cve_2021_23337",
    "name": "Prototype Pollution - Real CVE-2021-23337 vulnerability in lodash",
    "code": "// Real CVE-2021-23337 in Lodash\nfunction merge(object, sources) {\n    // Simplified version of vulnerable lodash merge\n    sources.forEach(source => {\n        for (let key in source) {\n            if (source.hasOwnProperty(key)) {\n                // VULNERABILITY: No protection against __proto__ pollution\n                if (typeof source[key] === 'object' && typeof object[key] === 'object') {\n                    merge(object[key], [source[key]]);\n                } else {\n                    object[key] = source[key];\n                }\n            }\n        }\n    });\n    return object;\n}\n\n// Attack payload: {\"__proto__\": {\"polluted\": true}}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Prototype Pollution",
        "cwe": "CWE-1321",
        "severity": "high",
        "description": "Real CVE-2021-23337 vulnerability in lodash"
      }
    ],
    "expectedFix": "Block dangerous keys and clone/validate objects before merge operations.",
    "metadata": {
      "sourceDataset": "real-world",
      "sourcePolicy": "external-only",
      "source": "lodash - CVE-2021-23337",
      "originalId": "real_world_lodash_cve_2021_23337",
      "vulnerableLines": [
        8,
        9
      ]
    }
  },
  {
    "id": "real_world_node-forge_cve_2022_24771",
    "name": "Crypto Verification - Real CVE-2022-24771 vulnerability in node-forge",
    "code": "// Real CVE-2022-24771 in node-forge\nconst crypto = require('crypto');\n\nfunction verifySignature(message, signature, publicKey) {\n    try {\n        // VULNERABILITY: Improper signature verification\n        const verify = crypto.createVerify('RSA-SHA256');\n        verify.update(message);\n        \n        // Missing proper signature format validation\n        return verify.verify(publicKey, signature, 'base64');\n    } catch (error) {\n        // Silently return true on error (vulnerable behavior)\n        return true;\n    }\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Crypto Verification",
        "cwe": "CWE-347",
        "severity": "high",
        "description": "Real CVE-2022-24771 vulnerability in node-forge"
      }
    ],
    "expectedFix": "Use constant-time comparison and verified cryptographic APIs.",
    "metadata": {
      "sourceDataset": "real-world",
      "sourcePolicy": "external-only",
      "source": "node-forge - CVE-2022-24771",
      "originalId": "real_world_node-forge_cve_2022_24771",
      "vulnerableLines": [
        8,
        9
      ]
    }
  },
  {
    "id": "adversarial_sqli_parameter_injection_original",
    "name": "SQL Injection - Adversarial test: SQL injection through parameter manipulation",
    "code": "// Adversarial: Multiple injection vectors\nfunction complexQuery(userId, role, filters) {\n    const query = `\n        SELECT u.*, r.permissions \n        FROM users u \n        JOIN roles r ON u.role_id = r.id \n        WHERE u.id = ${userId} \n        AND r.name = '${role}'\n        ${filters.where ? 'AND ' + filters.where : ''}\n        ORDER BY ${filters.orderBy || 'u.created_at'}\n    `;\n    return db.query(query);\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "SQL Injection",
        "cwe": "CWE-89",
        "severity": "high",
        "description": "Adversarial test: SQL injection through parameter manipulation"
      }
    ],
    "expectedFix": "Use parameterized SQL queries or prepared statements.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Original Pattern",
      "originalId": "adversarial_sqli_parameter_injection_original",
      "vulnerableLines": [
        12
      ]
    }
  },
  {
    "id": "adversarial_sqli_parameter_injection_obfuscated",
    "name": "SQL Injection - Adversarial test (obfuscated): SQL injection through parameter manipulation",
    "code": "// Obfuscated vulnerability pattern\n// Adversarial: Multiple injection vectors\nfunction complexQuery(userId, role, filters) {\n    const query = `\n        SELECT u.*, r.permissions \n        FROM users u \n        JOIN roles r ON u.role_id = r.id \n        WHERE u.id = ${userId} \n        AND r.name = '${role}'\n        ${filters.where ? 'AND ' + filters.where : ''}\n        ORDER BY ${filters.orderBy || 'u.created_at'}\n    `;\n    return db.query(query);\n}\n\n// Additional obfuscation layers\nconst obfuscatedFunc = Function.prototype.constructor;\nconst dynamicEval = obfuscatedFunc.constructor(\"return eval\")();\n",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "SQL Injection",
        "cwe": "CWE-89",
        "severity": "high",
        "description": "Adversarial test (obfuscated): SQL injection through parameter manipulation"
      }
    ],
    "expectedFix": "Use parameterized SQL queries or prepared statements.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Obfuscated",
      "originalId": "adversarial_sqli_parameter_injection_obfuscated",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_sqli_parameter_injection_minimal",
    "name": "SQL Injection - Adversarial test (minimal): SQL injection through parameter manipulation",
    "code": "function query(id) { return db.exec(\"SELECT * FROM users WHERE id=\" + id); }",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "SQL Injection",
        "cwe": "CWE-89",
        "severity": "medium",
        "description": "Adversarial test (minimal): SQL injection through parameter manipulation"
      }
    ],
    "expectedFix": "Use parameterized SQL queries or prepared statements.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Minimal",
      "originalId": "adversarial_sqli_parameter_injection_minimal",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_xss_context_switching_original",
    "name": "Cross-Site Scripting (XSS) - Adversarial test: XSS with context switching",
    "code": "// Adversarial: Context-aware XSS\nfunction renderUserProfile(user, template) {\n    const profileHtml = template\n        .replace('{{name}}', user.name)\n        .replace('{{bio}}', user.bio)\n        .replace('{{avatar}}', user.avatar);\n    \n    // Context switching vulnerability\n    if (user.isAdmin) {\n        profileHtml += `<script>window.userRole='${user.role}';</script>`;\n    }\n    \n    document.getElementById('profile').innerHTML = profileHtml;\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Cross-Site Scripting (XSS)",
        "cwe": "CWE-79",
        "severity": "high",
        "description": "Adversarial test: XSS with context switching"
      }
    ],
    "expectedFix": "Escape/sanitize untrusted content and avoid unsafe DOM sinks.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Original Pattern",
      "originalId": "adversarial_xss_context_switching_original",
      "vulnerableLines": [
        13
      ]
    }
  },
  {
    "id": "adversarial_xss_context_switching_obfuscated",
    "name": "Cross-Site Scripting (XSS) - Adversarial test (obfuscated): XSS with context switching",
    "code": "// Obfuscated vulnerability pattern\n// Adversarial: Context-aware XSS\nfunction renderUserProfile(user, template) {\n    const profileHtml = template\n        .replace('{{name}}', user.name)\n        .replace('{{bio}}', user.bio)\n        .replace('{{avatar}}', user.avatar);\n    \n    // Context switching vulnerability\n    if (user.isAdmin) {\n        profileHtml += `<script>window.userRole='${user.role}';</script>`;\n    }\n    \n    document.getElementById('profile').innerHTML = profileHtml;\n}\n\n// Additional obfuscation layers\nconst obfuscatedFunc = Function.prototype.constructor;\nconst dynamicEval = obfuscatedFunc.constructor(\"return eval\")();\n",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Cross-Site Scripting (XSS)",
        "cwe": "CWE-79",
        "severity": "high",
        "description": "Adversarial test (obfuscated): XSS with context switching"
      }
    ],
    "expectedFix": "Escape/sanitize untrusted content and avoid unsafe DOM sinks.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Obfuscated",
      "originalId": "adversarial_xss_context_switching_obfuscated",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_xss_context_switching_minimal",
    "name": "Cross-Site Scripting (XSS) - Adversarial test (minimal): XSS with context switching",
    "code": "function render(html) { document.body.innerHTML = html; }",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Cross-Site Scripting (XSS)",
        "cwe": "CWE-79",
        "severity": "medium",
        "description": "Adversarial test (minimal): XSS with context switching"
      }
    ],
    "expectedFix": "Escape/sanitize untrusted content and avoid unsafe DOM sinks.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Minimal",
      "originalId": "adversarial_xss_context_switching_minimal",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_path_traversal_double_encoding_original",
    "name": "Path Traversal - Adversarial test: Path traversal with encoding bypass",
    "code": "// Adversarial: Multiple encoding bypass\nconst path = require('path');\nconst fs = require('fs');\n\nfunction serveUserFile(filename, encoding = 'utf8') {\n    // Multiple normalization attempts\n    let sanitized = filename\n        .replace(/\\.\\./g, '')\n        .replace(/\\\\/g, '/')\n        .replace(/\\/+/g, '/');\n    \n    // Still vulnerable to double encoding\n    const filePath = path.join('./uploads', decodeURIComponent(sanitized));\n    return fs.readFileSync(filePath, encoding);\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Path Traversal",
        "cwe": "CWE-22",
        "severity": "high",
        "description": "Adversarial test: Path traversal with encoding bypass"
      }
    ],
    "expectedFix": "Canonicalize paths and restrict access to approved directories.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Original Pattern",
      "originalId": "adversarial_path_traversal_double_encoding_original",
      "vulnerableLines": [
        2,
        3,
        14
      ]
    }
  },
  {
    "id": "adversarial_path_traversal_double_encoding_obfuscated",
    "name": "Path Traversal - Adversarial test (obfuscated): Path traversal with encoding bypass",
    "code": "// Obfuscated vulnerability pattern\n// Adversarial: Multiple encoding bypass\nconst path = require('path');\nconst fs = require('fs');\n\nfunction serveUserFile(filename, encoding = 'utf8') {\n    // Multiple normalization attempts\n    let sanitized = filename\n        .replace(/\\.\\./g, '')\n        .replace(/\\\\/g, '/')\n        .replace(/\\/+/g, '/');\n    \n    // Still vulnerable to double encoding\n    const filePath = path.join('./uploads', decodeURIComponent(sanitized));\n    return fs.readFileSync(filePath, encoding);\n}\n\n// Additional obfuscation layers\nconst obfuscatedFunc = Function.prototype.constructor;\nconst dynamicEval = obfuscatedFunc.constructor(\"return eval\")();\n",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Path Traversal",
        "cwe": "CWE-22",
        "severity": "high",
        "description": "Adversarial test (obfuscated): Path traversal with encoding bypass"
      }
    ],
    "expectedFix": "Canonicalize paths and restrict access to approved directories.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Obfuscated",
      "originalId": "adversarial_path_traversal_double_encoding_obfuscated",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_path_traversal_double_encoding_minimal",
    "name": "Path Traversal - Adversarial test (minimal): Path traversal with encoding bypass",
    "code": "function readFile(path) { return fs.readFileSync(\"./files/\" + path); }",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Path Traversal",
        "cwe": "CWE-22",
        "severity": "medium",
        "description": "Adversarial test (minimal): Path traversal with encoding bypass"
      }
    ],
    "expectedFix": "Canonicalize paths and restrict access to approved directories.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Minimal",
      "originalId": "adversarial_path_traversal_double_encoding_minimal",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_prototype_pollution_nested_original",
    "name": "Prototype Pollution - Adversarial test: Nested prototype pollution",
    "code": "// Adversarial: Deep nested pollution\nfunction deepMergeConfig(target, source, depth = 0) {\n    if (depth > 10) return target; // Recursion limit\n    \n    for (const key in source) {\n        if (source[key] && typeof source[key] === 'object') {\n            if (!target[key]) target[key] = {};\n            deepMergeConfig(target[key], source[key], depth + 1);\n        } else {\n            target[key] = source[key]; // Pollution vector\n        }\n    }\n    return target;\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Prototype Pollution",
        "cwe": "CWE-1321",
        "severity": "high",
        "description": "Adversarial test: Nested prototype pollution"
      }
    ],
    "expectedFix": "Block dangerous keys and clone/validate objects before merge operations.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Original Pattern",
      "originalId": "adversarial_prototype_pollution_nested_original",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_prototype_pollution_nested_obfuscated",
    "name": "Prototype Pollution - Adversarial test (obfuscated): Nested prototype pollution",
    "code": "// Obfuscated vulnerability pattern\n// Adversarial: Deep nested pollution\nfunction deepMergeConfig(target, source, depth = 0) {\n    if (depth > 10) return target; // Recursion limit\n    \n    for (const key in source) {\n        if (source[key] && typeof source[key] === 'object') {\n            if (!target[key]) target[key] = {};\n            deepMergeConfig(target[key], source[key], depth + 1);\n        } else {\n            target[key] = source[key]; // Pollution vector\n        }\n    }\n    return target;\n}\n\n// Additional obfuscation layers\nconst obfuscatedFunc = Function.prototype.constructor;\nconst dynamicEval = obfuscatedFunc.constructor(\"return eval\")();\n",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Prototype Pollution",
        "cwe": "CWE-1321",
        "severity": "high",
        "description": "Adversarial test (obfuscated): Nested prototype pollution"
      }
    ],
    "expectedFix": "Block dangerous keys and clone/validate objects before merge operations.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Obfuscated",
      "originalId": "adversarial_prototype_pollution_nested_obfuscated",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_prototype_pollution_nested_minimal",
    "name": "Prototype Pollution - Adversarial test (minimal): Nested prototype pollution",
    "code": "function merge(obj, src) { for(let k in src) obj[k] = src[k]; }",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Prototype Pollution",
        "cwe": "CWE-1321",
        "severity": "medium",
        "description": "Adversarial test (minimal): Nested prototype pollution"
      }
    ],
    "expectedFix": "Block dangerous keys and clone/validate objects before merge operations.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Minimal",
      "originalId": "adversarial_prototype_pollution_nested_minimal",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_command_injection_template_original",
    "name": "Command Injection - Adversarial test: Command injection through template processing",
    "code": "// Adversarial: Template-based command injection\nconst { exec } = require('child_process');\n\nfunction processTemplate(template, data) {\n    // Template processing with command execution\n    const processed = template.replace(/\\\\{\\\\{([^}]+)\\\\}\\\\}/g, (match, expr) => {\n        try {\n            // Dangerous evaluation\n            return Function('\"use strict\"; return (' + expr + ')')();\n        } catch {\n            return match;\n        }\n    });\n    \n    if (data.executeCommand) {\n        exec(`echo \"${processed}\" > output.txt`);\n    }\n    \n    return processed;\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Command Injection",
        "cwe": "CWE-78",
        "severity": "high",
        "description": "Adversarial test: Command injection through template processing"
      }
    ],
    "expectedFix": "Use safe process APIs and never concatenate untrusted input into commands.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Original Pattern",
      "originalId": "adversarial_command_injection_template_original",
      "vulnerableLines": [
        2,
        9,
        16
      ]
    }
  },
  {
    "id": "adversarial_command_injection_template_obfuscated",
    "name": "Command Injection - Adversarial test (obfuscated): Command injection through template processing",
    "code": "// Obfuscated vulnerability pattern\n// Adversarial: Template-based command injection\nconst { exec } = require('child_process');\n\nfunction processTemplate(template, data) {\n    // Template processing with command execution\n    const processed = template.replace(/\\\\{\\\\{([^}]+)\\\\}\\\\}/g, (match, expr) => {\n        try {\n            // Dangerous evaluation\n            return Function('\"use strict\"; return (' + expr + ')')();\n        } catch {\n            return match;\n        }\n    });\n    \n    if (data.executeCommand) {\n        exec(`echo \"${processed}\" > output.txt`);\n    }\n    \n    return processed;\n}\n\n// Additional obfuscation layers\nconst obfuscatedFunc = Function.prototype.constructor;\nconst dynamicEval = obfuscatedFunc.constructor(\"return eval\")();\n",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Command Injection",
        "cwe": "CWE-78",
        "severity": "high",
        "description": "Adversarial test (obfuscated): Command injection through template processing"
      }
    ],
    "expectedFix": "Use safe process APIs and never concatenate untrusted input into commands.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Obfuscated",
      "originalId": "adversarial_command_injection_template_obfuscated",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_command_injection_template_minimal",
    "name": "Command Injection - Adversarial test (minimal): Command injection through template processing",
    "code": "function exec(cmd) { require(\"child_process\").exec(cmd); }",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Command Injection",
        "cwe": "CWE-78",
        "severity": "medium",
        "description": "Adversarial test (minimal): Command injection through template processing"
      }
    ],
    "expectedFix": "Use safe process APIs and never concatenate untrusted input into commands.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Minimal",
      "originalId": "adversarial_command_injection_template_minimal",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_crypto_timing_attack_original",
    "name": "Weak Cryptography - Adversarial test: Cryptographic timing attack",
    "code": "// Adversarial: Timing attack vulnerability\nfunction verifyApiKey(providedKey, validKey) {\n    if (providedKey.length !== validKey.length) {\n        return false;\n    }\n    \n    // Vulnerable: Early termination allows timing attacks\n    for (let i = 0; i < providedKey.length; i++) {\n        if (providedKey[i] !== validKey[i]) {\n            return false; // Timing leak here\n        }\n    }\n    \n    return true;\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Weak Cryptography",
        "cwe": "CWE-208",
        "severity": "high",
        "description": "Adversarial test: Cryptographic timing attack"
      }
    ],
    "expectedFix": "Replace weak cryptographic primitives with modern approved algorithms.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Original Pattern",
      "originalId": "adversarial_crypto_timing_attack_original",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_crypto_timing_attack_obfuscated",
    "name": "Weak Cryptography - Adversarial test (obfuscated): Cryptographic timing attack",
    "code": "// Obfuscated vulnerability pattern\n// Adversarial: Timing attack vulnerability\nfunction verifyApiKey(providedKey, validKey) {\n    if (providedKey.length !== validKey.length) {\n        return false;\n    }\n    \n    // Vulnerable: Early termination allows timing attacks\n    for (let i = 0; i < providedKey.length; i++) {\n        if (providedKey[i] !== validKey[i]) {\n            return false; // Timing leak here\n        }\n    }\n    \n    return true;\n}\n\n// Additional obfuscation layers\nconst obfuscatedFunc = Function.prototype.constructor;\nconst dynamicEval = obfuscatedFunc.constructor(\"return eval\")();\n",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Weak Cryptography",
        "cwe": "CWE-208",
        "severity": "high",
        "description": "Adversarial test (obfuscated): Cryptographic timing attack"
      }
    ],
    "expectedFix": "Replace weak cryptographic primitives with modern approved algorithms.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Obfuscated",
      "originalId": "adversarial_crypto_timing_attack_obfuscated",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_crypto_timing_attack_minimal",
    "name": "Weak Cryptography - Adversarial test (minimal): Cryptographic timing attack",
    "code": "function compare(a, b) { return a === b; }",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Weak Cryptography",
        "cwe": "CWE-208",
        "severity": "medium",
        "description": "Adversarial test (minimal): Cryptographic timing attack"
      }
    ],
    "expectedFix": "Replace weak cryptographic primitives with modern approved algorithms.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Minimal",
      "originalId": "adversarial_crypto_timing_attack_minimal",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_deserialization_gadget_original",
    "name": "Insecure Deserialization - Adversarial test: Unsafe deserialization with gadget chain",
    "code": "// Adversarial: Deserialization gadget chain\nclass UserSession {\n    constructor(data) {\n        Object.assign(this, data);\n    }\n    \n    toJSON() {\n        return { ...this, serializedAt: Date.now() };\n    }\n    \n    static fromJSON(jsonStr) {\n        const data = JSON.parse(jsonStr);\n        // Vulnerable: Automatic property assignment\n        return new UserSession(data);\n    }\n}\n\nfunction loadUserSession(sessionData) {\n    return UserSession.fromJSON(sessionData);\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Insecure Deserialization",
        "cwe": "CWE-502",
        "severity": "high",
        "description": "Adversarial test: Unsafe deserialization with gadget chain"
      }
    ],
    "expectedFix": "Avoid unsafe deserialization and enforce strict schema validation.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Original Pattern",
      "originalId": "adversarial_deserialization_gadget_original",
      "vulnerableLines": [
        4,
        12
      ]
    }
  },
  {
    "id": "adversarial_deserialization_gadget_obfuscated",
    "name": "Insecure Deserialization - Adversarial test (obfuscated): Unsafe deserialization with gadget chain",
    "code": "// Obfuscated vulnerability pattern\n// Adversarial: Deserialization gadget chain\nclass UserSession {\n    constructor(data) {\n        Object.assign(this, data);\n    }\n    \n    toJSON() {\n        return { ...this, serializedAt: Date.now() };\n    }\n    \n    static fromJSON(jsonStr) {\n        const data = JSON.parse(jsonStr);\n        // Vulnerable: Automatic property assignment\n        return new UserSession(data);\n    }\n}\n\nfunction loadUserSession(sessionData) {\n    return UserSession.fromJSON(sessionData);\n}\n\n// Additional obfuscation layers\nconst obfuscatedFunc = Function.prototype.constructor;\nconst dynamicEval = obfuscatedFunc.constructor(\"return eval\")();\n",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Insecure Deserialization",
        "cwe": "CWE-502",
        "severity": "high",
        "description": "Adversarial test (obfuscated): Unsafe deserialization with gadget chain"
      }
    ],
    "expectedFix": "Avoid unsafe deserialization and enforce strict schema validation.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Obfuscated",
      "originalId": "adversarial_deserialization_gadget_obfuscated",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_deserialization_gadget_minimal",
    "name": "Insecure Deserialization - Adversarial test (minimal): Unsafe deserialization with gadget chain",
    "code": "function load(data) { return Object.assign({}, JSON.parse(data)); }",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Insecure Deserialization",
        "cwe": "CWE-502",
        "severity": "medium",
        "description": "Adversarial test (minimal): Unsafe deserialization with gadget chain"
      }
    ],
    "expectedFix": "Avoid unsafe deserialization and enforce strict schema validation.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Minimal",
      "originalId": "adversarial_deserialization_gadget_minimal",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_nosql_injection_aggregation_original",
    "name": "NoSQL Injection - Adversarial test: NoSQL injection in aggregation pipeline",
    "code": "// Adversarial: NoSQL injection via aggregation\nfunction getUserAnalytics(userId, filters) {\n    const pipeline = [\n        { $match: { userId: userId } },\n        { $group: { _id: \"$category\", total: { $sum: 1 } } }\n    ];\n    \n    // Vulnerable: Direct filter injection\n    if (filters.customStage) {\n        pipeline.push(JSON.parse(filters.customStage));\n    }\n    \n    return db.collection('events').aggregate(pipeline).toArray();\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "NoSQL Injection",
        "cwe": "CWE-943",
        "severity": "high",
        "description": "Adversarial test: NoSQL injection in aggregation pipeline"
      }
    ],
    "expectedFix": "Use parameterized query objects and validate query operators/fields.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Original Pattern",
      "originalId": "adversarial_nosql_injection_aggregation_original",
      "vulnerableLines": [
        10
      ]
    }
  },
  {
    "id": "adversarial_nosql_injection_aggregation_obfuscated",
    "name": "NoSQL Injection - Adversarial test (obfuscated): NoSQL injection in aggregation pipeline",
    "code": "// Obfuscated vulnerability pattern\n// Adversarial: NoSQL injection via aggregation\nfunction getUserAnalytics(userId, filters) {\n    const pipeline = [\n        { $match: { userId: userId } },\n        { $group: { _id: \"$category\", total: { $sum: 1 } } }\n    ];\n    \n    // Vulnerable: Direct filter injection\n    if (filters.customStage) {\n        pipeline.push(JSON.parse(filters.customStage));\n    }\n    \n    return db.collection('events').aggregate(pipeline).toArray();\n}\n\n// Additional obfuscation layers\nconst obfuscatedFunc = Function.prototype.constructor;\nconst dynamicEval = obfuscatedFunc.constructor(\"return eval\")();\n",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "NoSQL Injection",
        "cwe": "CWE-943",
        "severity": "high",
        "description": "Adversarial test (obfuscated): NoSQL injection in aggregation pipeline"
      }
    ],
    "expectedFix": "Use parameterized query objects and validate query operators/fields.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Obfuscated",
      "originalId": "adversarial_nosql_injection_aggregation_obfuscated",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_nosql_injection_aggregation_minimal",
    "name": "NoSQL Injection - Adversarial test (minimal): NoSQL injection in aggregation pipeline",
    "code": "function vuln() { /* minimal vulnerability */ }",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "NoSQL Injection",
        "cwe": "CWE-943",
        "severity": "medium",
        "description": "Adversarial test (minimal): NoSQL injection in aggregation pipeline"
      }
    ],
    "expectedFix": "Use parameterized query objects and validate query operators/fields.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Minimal",
      "originalId": "adversarial_nosql_injection_aggregation_minimal",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_regex_dos_backtrack_original",
    "name": "Regular Expression DoS - Adversarial test: ReDoS via catastrophic backtracking",
    "code": "// Adversarial: Regex catastrophic backtracking\nfunction validateEmail(email) {\n    // Vulnerable: Catastrophic backtracking pattern\n    const emailRegex = /^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5})$/;\n    const complexRegex = /^(a+)+b$/;\n    \n    if (complexRegex.test(email)) {\n        return emailRegex.test(email);\n    }\n    \n    return false;\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Regular Expression DoS",
        "cwe": "CWE-1333",
        "severity": "high",
        "description": "Adversarial test: ReDoS via catastrophic backtracking"
      }
    ],
    "expectedFix": "Avoid catastrophic regex patterns and enforce input/time limits.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Original Pattern",
      "originalId": "adversarial_regex_dos_backtrack_original",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_regex_dos_backtrack_obfuscated",
    "name": "Regular Expression DoS - Adversarial test (obfuscated): ReDoS via catastrophic backtracking",
    "code": "// Obfuscated vulnerability pattern\n// Adversarial: Regex catastrophic backtracking\nfunction validateEmail(email) {\n    // Vulnerable: Catastrophic backtracking pattern\n    const emailRegex = /^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5})$/;\n    const complexRegex = /^(a+)+b$/;\n    \n    if (complexRegex.test(email)) {\n        return emailRegex.test(email);\n    }\n    \n    return false;\n}\n\n// Additional obfuscation layers\nconst obfuscatedFunc = Function.prototype.constructor;\nconst dynamicEval = obfuscatedFunc.constructor(\"return eval\")();\n",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Regular Expression DoS",
        "cwe": "CWE-1333",
        "severity": "high",
        "description": "Adversarial test (obfuscated): ReDoS via catastrophic backtracking"
      }
    ],
    "expectedFix": "Avoid catastrophic regex patterns and enforce input/time limits.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Obfuscated",
      "originalId": "adversarial_regex_dos_backtrack_obfuscated",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_regex_dos_backtrack_minimal",
    "name": "Regular Expression DoS - Adversarial test (minimal): ReDoS via catastrophic backtracking",
    "code": "function vuln() { /* minimal vulnerability */ }",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Regular Expression DoS",
        "cwe": "CWE-1333",
        "severity": "medium",
        "description": "Adversarial test (minimal): ReDoS via catastrophic backtracking"
      }
    ],
    "expectedFix": "Avoid catastrophic regex patterns and enforce input/time limits.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Minimal",
      "originalId": "adversarial_regex_dos_backtrack_minimal",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_jwt_algorithm_confusion_original",
    "name": "Authentication Bypass - Adversarial test: JWT algorithm confusion attack",
    "code": "// Adversarial: JWT algorithm confusion\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\n\nfunction verifyToken(token, publicKey) {\n    try {\n        // Vulnerable: No algorithm specification\n        const decoded = jwt.verify(token, publicKey);\n        return decoded;\n    } catch (error) {\n        // Fallback to 'none' algorithm\n        const parts = token.split('.');\n        if (parts.length === 3) {\n            return JSON.parse(Buffer.from(parts[1], 'base64').toString());\n        }\n        throw error;\n    }\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Authentication Bypass",
        "cwe": "CWE-287",
        "severity": "high",
        "description": "Adversarial test: JWT algorithm confusion attack"
      }
    ],
    "expectedFix": "Harden authentication checks and validate token/session integrity.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Original Pattern",
      "originalId": "adversarial_jwt_algorithm_confusion_original",
      "vulnerableLines": [
        2,
        3,
        14
      ]
    }
  },
  {
    "id": "adversarial_jwt_algorithm_confusion_obfuscated",
    "name": "Authentication Bypass - Adversarial test (obfuscated): JWT algorithm confusion attack",
    "code": "// Obfuscated vulnerability pattern\n// Adversarial: JWT algorithm confusion\nconst jwt = require('jsonwebtoken');\nconst fs = require('fs');\n\nfunction verifyToken(token, publicKey) {\n    try {\n        // Vulnerable: No algorithm specification\n        const decoded = jwt.verify(token, publicKey);\n        return decoded;\n    } catch (error) {\n        // Fallback to 'none' algorithm\n        const parts = token.split('.');\n        if (parts.length === 3) {\n            return JSON.parse(Buffer.from(parts[1], 'base64').toString());\n        }\n        throw error;\n    }\n}\n\n// Additional obfuscation layers\nconst obfuscatedFunc = Function.prototype.constructor;\nconst dynamicEval = obfuscatedFunc.constructor(\"return eval\")();\n",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Authentication Bypass",
        "cwe": "CWE-287",
        "severity": "high",
        "description": "Adversarial test (obfuscated): JWT algorithm confusion attack"
      }
    ],
    "expectedFix": "Harden authentication checks and validate token/session integrity.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Obfuscated",
      "originalId": "adversarial_jwt_algorithm_confusion_obfuscated",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_jwt_algorithm_confusion_minimal",
    "name": "Authentication Bypass - Adversarial test (minimal): JWT algorithm confusion attack",
    "code": "function vuln() { /* minimal vulnerability */ }",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Authentication Bypass",
        "cwe": "CWE-287",
        "severity": "medium",
        "description": "Adversarial test (minimal): JWT algorithm confusion attack"
      }
    ],
    "expectedFix": "Harden authentication checks and validate token/session integrity.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Minimal",
      "originalId": "adversarial_jwt_algorithm_confusion_minimal",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_ssrf_url_bypass_original",
    "name": "Server-Side Request Forgery (SSRF) - Adversarial test: SSRF with URL validation bypass",
    "code": "// Adversarial: SSRF URL bypass techniques\nconst http = require('http');\nconst url = require('url');\n\nfunction fetchResource(resourceUrl) {\n    const parsed = url.parse(resourceUrl);\n    \n    // Vulnerable: Insufficient blacklist\n    const blockedHosts = ['localhost', '127.0.0.1', '0.0.0.0'];\n    \n    if (blockedHosts.includes(parsed.hostname)) {\n        throw new Error('Blocked host');\n    }\n    \n    // Still vulnerable to bypass techniques\n    return new Promise((resolve, reject) => {\n        http.get(resourceUrl, (res) => {\n            let data = '';\n            res.on('data', chunk => data += chunk);\n            res.on('end', () => resolve(data));\n        }).on('error', reject);\n    });\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Server-Side Request Forgery (SSRF)",
        "cwe": "CWE-918",
        "severity": "high",
        "description": "Adversarial test: SSRF with URL validation bypass"
      }
    ],
    "expectedFix": "Validate outbound targets and restrict requests with allowlists/network controls.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Original Pattern",
      "originalId": "adversarial_ssrf_url_bypass_original",
      "vulnerableLines": [
        2,
        3
      ]
    }
  },
  {
    "id": "adversarial_ssrf_url_bypass_obfuscated",
    "name": "Server-Side Request Forgery (SSRF) - Adversarial test (obfuscated): SSRF with URL validation bypass",
    "code": "// Obfuscated vulnerability pattern\n// Adversarial: SSRF URL bypass techniques\nconst http = require('http');\nconst url = require('url');\n\nfunction fetchResource(resourceUrl) {\n    const parsed = url.parse(resourceUrl);\n    \n    // Vulnerable: Insufficient blacklist\n    const blockedHosts = ['localhost', '127.0.0.1', '0.0.0.0'];\n    \n    if (blockedHosts.includes(parsed.hostname)) {\n        throw new Error('Blocked host');\n    }\n    \n    // Still vulnerable to bypass techniques\n    return new Promise((resolve, reject) => {\n        http.get(resourceUrl, (res) => {\n            let data = '';\n            res.on('data', chunk => data += chunk);\n            res.on('end', () => resolve(data));\n        }).on('error', reject);\n    });\n}\n\n// Additional obfuscation layers\nconst obfuscatedFunc = Function.prototype.constructor;\nconst dynamicEval = obfuscatedFunc.constructor(\"return eval\")();\n",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Server-Side Request Forgery (SSRF)",
        "cwe": "CWE-918",
        "severity": "high",
        "description": "Adversarial test (obfuscated): SSRF with URL validation bypass"
      }
    ],
    "expectedFix": "Validate outbound targets and restrict requests with allowlists/network controls.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Obfuscated",
      "originalId": "adversarial_ssrf_url_bypass_obfuscated",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_ssrf_url_bypass_minimal",
    "name": "Server-Side Request Forgery (SSRF) - Adversarial test (minimal): SSRF with URL validation bypass",
    "code": "function vuln() { /* minimal vulnerability */ }",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Server-Side Request Forgery (SSRF)",
        "cwe": "CWE-918",
        "severity": "medium",
        "description": "Adversarial test (minimal): SSRF with URL validation bypass"
      }
    ],
    "expectedFix": "Validate outbound targets and restrict requests with allowlists/network controls.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Minimal",
      "originalId": "adversarial_ssrf_url_bypass_minimal",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_ldap_injection_blind_original",
    "name": "LDAP Injection - Adversarial test: Blind LDAP injection",
    "code": "// Adversarial: Blind LDAP injection\nconst ldap = require('ldapjs');\n\nfunction searchUsers(username, attribute) {\n    const client = ldap.createClient({ url: 'ldap://ldap.company.com' });\n    \n    // Vulnerable: Unescaped LDAP filter construction\n    const filter = `(&(uid=${username})(${attribute}=*))`;\n    \n    return new Promise((resolve, reject) => {\n        client.search('ou=users,dc=company,dc=com', {\n            filter: filter,\n            scope: 'sub'\n        }, (err, result) => {\n            if (err) reject(err);\n            \n            const entries = [];\n            result.on('searchEntry', entry => entries.push(entry.object));\n            result.on('end', () => resolve(entries));\n        });\n    });\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "LDAP Injection",
        "cwe": "CWE-90",
        "severity": "high",
        "description": "Adversarial test: Blind LDAP injection"
      }
    ],
    "expectedFix": "Use parameterized LDAP queries and sanitize user-controlled input.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Original Pattern",
      "originalId": "adversarial_ldap_injection_blind_original",
      "vulnerableLines": [
        2
      ]
    }
  },
  {
    "id": "adversarial_ldap_injection_blind_obfuscated",
    "name": "LDAP Injection - Adversarial test (obfuscated): Blind LDAP injection",
    "code": "// Obfuscated vulnerability pattern\n// Adversarial: Blind LDAP injection\nconst ldap = require('ldapjs');\n\nfunction searchUsers(username, attribute) {\n    const client = ldap.createClient({ url: 'ldap://ldap.company.com' });\n    \n    // Vulnerable: Unescaped LDAP filter construction\n    const filter = `(&(uid=${username})(${attribute}=*))`;\n    \n    return new Promise((resolve, reject) => {\n        client.search('ou=users,dc=company,dc=com', {\n            filter: filter,\n            scope: 'sub'\n        }, (err, result) => {\n            if (err) reject(err);\n            \n            const entries = [];\n            result.on('searchEntry', entry => entries.push(entry.object));\n            result.on('end', () => resolve(entries));\n        });\n    });\n}\n\n// Additional obfuscation layers\nconst obfuscatedFunc = Function.prototype.constructor;\nconst dynamicEval = obfuscatedFunc.constructor(\"return eval\")();\n",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "LDAP Injection",
        "cwe": "CWE-90",
        "severity": "high",
        "description": "Adversarial test (obfuscated): Blind LDAP injection"
      }
    ],
    "expectedFix": "Use parameterized LDAP queries and sanitize user-controlled input.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Obfuscated",
      "originalId": "adversarial_ldap_injection_blind_obfuscated",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_ldap_injection_blind_minimal",
    "name": "LDAP Injection - Adversarial test (minimal): Blind LDAP injection",
    "code": "function vuln() { /* minimal vulnerability */ }",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "LDAP Injection",
        "cwe": "CWE-90",
        "severity": "medium",
        "description": "Adversarial test (minimal): Blind LDAP injection"
      }
    ],
    "expectedFix": "Use parameterized LDAP queries and sanitize user-controlled input.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Minimal",
      "originalId": "adversarial_ldap_injection_blind_minimal",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_race_condition_toctou_original",
    "name": "Race Condition - Adversarial test: Time-of-check to time-of-use race condition",
    "code": "// Adversarial: TOCTOU race condition\nconst fs = require('fs');\n\nclass FileProcessor {\n    constructor() {\n        this.processing = new Set();\n    }\n    \n    async processFile(filename) {\n        // Vulnerable: Check and use are separate\n        if (this.processing.has(filename)) {\n            throw new Error('File already being processed');\n        }\n        \n        // Race condition window here\n        await new Promise(resolve => setTimeout(resolve, 10));\n        \n        this.processing.add(filename);\n        \n        try {\n            const content = fs.readFileSync(filename, 'utf8');\n            return this.transform(content);\n        } finally {\n            this.processing.delete(filename);\n        }\n    }\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Race Condition",
        "cwe": "CWE-362",
        "severity": "high",
        "description": "Adversarial test: Time-of-check to time-of-use race condition"
      }
    ],
    "expectedFix": "Use synchronization/atomic operations to protect shared state.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Original Pattern",
      "originalId": "adversarial_race_condition_toctou_original",
      "vulnerableLines": [
        2,
        21
      ]
    }
  },
  {
    "id": "adversarial_race_condition_toctou_obfuscated",
    "name": "Race Condition - Adversarial test (obfuscated): Time-of-check to time-of-use race condition",
    "code": "// Obfuscated vulnerability pattern\n// Adversarial: TOCTOU race condition\nconst fs = require('fs');\n\nclass FileProcessor {\n    constructor() {\n        this.processing = new Set();\n    }\n    \n    async processFile(filename) {\n        // Vulnerable: Check and use are separate\n        if (this.processing.has(filename)) {\n            throw new Error('File already being processed');\n        }\n        \n        // Race condition window here\n        await new Promise(resolve => setTimeout(resolve, 10));\n        \n        this.processing.add(filename);\n        \n        try {\n            const content = fs.readFileSync(filename, 'utf8');\n            return this.transform(content);\n        } finally {\n            this.processing.delete(filename);\n        }\n    }\n}\n\n// Additional obfuscation layers\nconst obfuscatedFunc = Function.prototype.constructor;\nconst dynamicEval = obfuscatedFunc.constructor(\"return eval\")();\n",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Race Condition",
        "cwe": "CWE-362",
        "severity": "high",
        "description": "Adversarial test (obfuscated): Time-of-check to time-of-use race condition"
      }
    ],
    "expectedFix": "Use synchronization/atomic operations to protect shared state.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Obfuscated",
      "originalId": "adversarial_race_condition_toctou_obfuscated",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_race_condition_toctou_minimal",
    "name": "Race Condition - Adversarial test (minimal): Time-of-check to time-of-use race condition",
    "code": "function vuln() { /* minimal vulnerability */ }",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "Race Condition",
        "cwe": "CWE-362",
        "severity": "medium",
        "description": "Adversarial test (minimal): Time-of-check to time-of-use race condition"
      }
    ],
    "expectedFix": "Use synchronization/atomic operations to protect shared state.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Minimal",
      "originalId": "adversarial_race_condition_toctou_minimal",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_xml_external_entity_original",
    "name": "XML External Entity (XXE) - Adversarial test: XXE via XML processing",
    "code": "// Adversarial: XXE vulnerability\nconst xml2js = require('xml2js');\n\nfunction parseXmlConfig(xmlData) {\n    const parser = new xml2js.Parser({\n        // Vulnerable: External entities enabled\n        explicitDoctype: true,\n        normalize: false,\n        normalizeTags: false,\n        explicitCharkey: false\n    });\n    \n    return new Promise((resolve, reject) => {\n        parser.parseString(xmlData, (err, result) => {\n            if (err) reject(err);\n            else resolve(result);\n        });\n    });\n}",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "XML External Entity (XXE)",
        "cwe": "CWE-611",
        "severity": "high",
        "description": "Adversarial test: XXE via XML processing"
      }
    ],
    "expectedFix": "Disable external entities and DTD processing in XML parsers.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Original Pattern",
      "originalId": "adversarial_xml_external_entity_original",
      "vulnerableLines": [
        2
      ]
    }
  },
  {
    "id": "adversarial_xml_external_entity_obfuscated",
    "name": "XML External Entity (XXE) - Adversarial test (obfuscated): XXE via XML processing",
    "code": "// Obfuscated vulnerability pattern\n// Adversarial: XXE vulnerability\nconst xml2js = require('xml2js');\n\nfunction parseXmlConfig(xmlData) {\n    const parser = new xml2js.Parser({\n        // Vulnerable: External entities enabled\n        explicitDoctype: true,\n        normalize: false,\n        normalizeTags: false,\n        explicitCharkey: false\n    });\n    \n    return new Promise((resolve, reject) => {\n        parser.parseString(xmlData, (err, result) => {\n            if (err) reject(err);\n            else resolve(result);\n        });\n    });\n}\n\n// Additional obfuscation layers\nconst obfuscatedFunc = Function.prototype.constructor;\nconst dynamicEval = obfuscatedFunc.constructor(\"return eval\")();\n",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "XML External Entity (XXE)",
        "cwe": "CWE-611",
        "severity": "high",
        "description": "Adversarial test (obfuscated): XXE via XML processing"
      }
    ],
    "expectedFix": "Disable external entities and DTD processing in XML parsers.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Obfuscated",
      "originalId": "adversarial_xml_external_entity_obfuscated",
      "vulnerableLines": [
        1
      ]
    }
  },
  {
    "id": "adversarial_xml_external_entity_minimal",
    "name": "XML External Entity (XXE) - Adversarial test (minimal): XXE via XML processing",
    "code": "function vuln() { /* minimal vulnerability */ }",
    "language": "javascript",
    "expectedVulnerabilities": [
      {
        "type": "XML External Entity (XXE)",
        "cwe": "CWE-611",
        "severity": "medium",
        "description": "Adversarial test (minimal): XXE via XML processing"
      }
    ],
    "expectedFix": "Disable external entities and DTD processing in XML parsers.",
    "metadata": {
      "sourceDataset": "adversarial",
      "sourcePolicy": "external-only",
      "source": "Adversarial - Minimal",
      "originalId": "adversarial_xml_external_entity_minimal",
      "vulnerableLines": [
        1
      ]
    }
  }
]
