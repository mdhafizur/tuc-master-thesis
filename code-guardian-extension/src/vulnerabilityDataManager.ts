import * as vscode from 'vscode';
import * as https from 'https';
import * as fs from 'fs';
import * as fsPromises from 'fs/promises';
import * as path from 'path';
import { getLogger } from './logger';

export interface VulnerabilityData {
    id: string;
    title: string;
    description: string;
    severity: 'critical' | 'high' | 'medium' | 'low';
    cwe?: string;
    cve?: string;
    owasp?: string;
    mitigation: string;
    examples: string[];
    references: string[];
    lastUpdated: string;
    source: 'nvd' | 'cwe' | 'owasp' | 'custom';
    tags: string[];
}

export interface CVEData {
    cve: {
        id: string;
        descriptions: Array<{
            lang: string;
            value: string;
        }>;
        metrics?: {
            cvssMetricV31?: Array<{
                cvssData: {
                    baseScore: number;
                    baseSeverity: string;
                };
            }>;
        };
        weaknesses?: Array<{
            description: Array<{
                lang: string;
                value: string;
            }>;
        }>;
        references?: Array<{
            url: string;
            tags?: string[];
        }>;
    };
}

export interface CWEData {
    id: string;
    name: string;
    description: string;
    extended_description?: string;
    likelihood_of_exploit?: string;
    common_consequences?: Array<{
        scope: string[];
        impact: string[];
    }>;
    potential_mitigations?: Array<{
        phase: string[];
        description: string;
    }>;
}

export class VulnerabilityDataManager {
    private readonly dataPath: string;
    private readonly cacheExpiry = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
    private readonly logger = getLogger();

    constructor(private context: vscode.ExtensionContext) {
        this.dataPath = path.join(context.extensionPath, 'vulnerability-data');
        this.ensureDataDirectory();
    }

    private ensureDataDirectory() {
        if (!fs.existsSync(this.dataPath)) {
            fs.mkdirSync(this.dataPath, { recursive: true });
        }
    }

    private async fetchWithTimeout(url: string, timeout = 30000): Promise<string> {
        return new Promise((resolve, reject) => {
            const timer = setTimeout(() => {
                reject(new Error(`Request timeout: ${url}`));
            }, timeout);

            https.get(url, {
                headers: {
                    'User-Agent': 'VS-Code-Extension-CodeGuardian/1.0'
                }
            }, (response) => {
                let data = '';
                
                response.on('data', (chunk) => {
                    data += chunk;
                });

                response.on('end', () => {
                    clearTimeout(timer);
                    if (response.statusCode === 200) {
                        resolve(data);
                    } else {
                        reject(new Error(`HTTP ${response.statusCode}: ${response.statusMessage}`));
                    }
                });

                response.on('error', (error) => {
                    clearTimeout(timer);
                    reject(error);
                });
            }).on('error', (error) => {
                clearTimeout(timer);
                reject(error);
            });
        });
    }

    private isCacheValid(filePath: string): boolean {
        if (!fs.existsSync(filePath)) {
            return false;
        }

        const stats = fs.statSync(filePath);
        const age = Date.now() - stats.mtime.getTime();
        return age < this.cacheExpiry;
    }

    async fetchCWEData(cweIds: string[] = [
        '79',   // XSS
        '89',   // SQL Injection
        '22',   // Path Traversal
        '352',  // CSRF
        '434',  // Unrestricted Upload
        '502',  // Deserialization
        '611',  // XML External Entities
        '798',  // Hard-coded Credentials
        '863',  // Incorrect Authorization
        '1321', // Prototype Pollution
        '94',   // Code Injection
        '95',   // Eval Injection
        '117',  // Improper Output Neutralization
        '200',  // Information Exposure
        '269',  // Improper Privilege Management
        '287',  // Improper Authentication
        '306',  // Missing Authentication
        '327',  // Weak Encryption
        '328',  // Weak Hash
        '347'   // Improper Certificate Validation
    ]): Promise<VulnerabilityData[]> {
        const cacheFile = path.join(this.dataPath, 'cwe-data.json');
        
        // Check cache first
        if (this.isCacheValid(cacheFile)) {
            try {
                const cached = JSON.parse(await fsPromises.readFile(cacheFile, 'utf8'));
                this.logger.debug('Using cached CWE data');
                return cached;
            } catch (error) {
                this.logger.warn('Failed to read CWE cache:', error);
            }
        }

        this.logger.info('Fetching fresh CWE data...');
        const vulnerabilities: VulnerabilityData[] = [];

        for (const cweId of cweIds) {
            try {
                // Note: CWE doesn't have a public API, so we'll use a combination of 
                // MITRE's CWE data and our curated knowledge
                const vuln = await this.getCWEVulnerability(cweId);
                if (vuln) {
                    vulnerabilities.push(vuln);
                }
            } catch (error) {
                this.logger.error(`Failed to fetch CWE-${cweId}:`, error);
            }
        }

        // Cache the results
        try {
            await fsPromises.writeFile(cacheFile, JSON.stringify(vulnerabilities, null, 2));
        } catch (error) {
            this.logger.warn('Failed to cache CWE data:', error);
        }

        return vulnerabilities;
    }

    private async getCWEVulnerability(cweId: string): Promise<VulnerabilityData | null> {
        // Since CWE doesn't have a direct API, we'll use curated data based on CWE definitions
        const cweDatabase: { [key: string]: Partial<VulnerabilityData> } = {
            '79': {
                title: 'Cross-site Scripting (XSS)',
                description: 'The software does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.',
                severity: 'high',
                cwe: 'CWE-79',
                owasp: 'A03:2021',
                mitigation: `1. Input Validation: Validate all input on the server side
2. Output Encoding: Encode data when outputting to HTML, JavaScript, CSS, or URL contexts
3. Content Security Policy (CSP): Implement CSP headers to prevent script execution
4. Use Safe APIs: Use frameworks that automatically escape XSS
5. Sanitization: Use established sanitization libraries`,
                examples: [
                    'document.getElementById("div").innerHTML = userInput; // Vulnerable',
                    'document.getElementById("div").textContent = userInput; // Safe',
                    'element.setAttribute("href", "javascript:" + userInput); // Vulnerable',
                    'DOMPurify.sanitize(userInput); // Safe with sanitization library'
                ],
                tags: ['xss', 'injection', 'javascript', 'web-security', 'input-validation']
            },
            '89': {
                title: 'SQL Injection',
                description: 'The software constructs all or part of an SQL command using externally-influenced input but does not neutralize special elements that could modify the intended SQL command.',
                severity: 'critical',
                cwe: 'CWE-89',
                owasp: 'A03:2021',
                mitigation: `1. Parameterized Queries: Use prepared statements with parameter binding
2. Input Validation: Validate input type, length, format, and range
3. Least Privilege: Use database accounts with minimal necessary privileges
4. Escape Special Characters: Properly escape SQL special characters
5. Stored Procedures: Use stored procedures with proper input validation`,
                examples: [
                    'SELECT * FROM users WHERE id = " + userId + "; // Vulnerable',
                    'SELECT * FROM users WHERE id = ?; // Safe with prepared statement',
                    'db.query("SELECT * FROM users WHERE name = \'" + username + "\'"); // Vulnerable',
                    'db.query("SELECT * FROM users WHERE name = ?", [username]); // Safe'
                ],
                tags: ['sql-injection', 'database', 'injection', 'parameterized-queries']
            },
            '22': {
                title: 'Path Traversal',
                description: 'The software uses external input to construct a pathname that is intended to identify a file or directory, but it does not properly neutralize special elements that can cause the pathname to resolve to a location that is outside of the restricted directory.',
                severity: 'high',
                cwe: 'CWE-22',
                owasp: 'A01:2021',
                mitigation: `1. Input Validation: Validate and sanitize file paths
2. Whitelist Approach: Use allowlists of acceptable file names/paths
3. Canonical Paths: Convert to canonical form and verify within bounds
4. Chroot Jails: Use chroot environments to restrict file access
5. Avoid User Input: Don't use user input directly in file operations`,
                examples: [
                    'fs.readFile(userInput, callback); // Vulnerable',
                    'fs.readFile(path.join(safeDir, path.basename(userInput)), callback); // Safer',
                    'res.sendFile(req.params.file); // Vulnerable',
                    'res.sendFile(path.resolve(__dirname, "safe", req.params.file)); // Safer'
                ],
                tags: ['path-traversal', 'file-system', 'directory-traversal', 'input-validation']
            },
            '352': {
                title: 'Cross-Site Request Forgery (CSRF)',
                description: 'The web application does not verify whether a request was intentionally provided by the user who submitted the request.',
                severity: 'medium',
                cwe: 'CWE-352',
                owasp: 'A01:2021',
                mitigation: `1. CSRF Tokens: Use synchronizer tokens in forms and AJAX requests
2. SameSite Cookies: Set SameSite attribute on cookies
3. Origin Validation: Verify Origin and Referer headers
4. Double Submit Cookie: Use double submit cookie pattern
5. Custom Headers: Require custom headers for state-changing requests`,
                examples: [
                    '<form action="/transfer" method="POST"> // Vulnerable without CSRF token',
                    '<form action="/transfer" method="POST"><input type="hidden" name="_token" value="{{csrfToken}}"> // Protected',
                    'fetch("/api/delete", {method: "POST"}); // Vulnerable',
                    'fetch("/api/delete", {method: "POST", headers: {"X-CSRF-Token": token}}); // Protected'
                ],
                tags: ['csrf', 'web-security', 'tokens', 'state-changing-operations']
            },
            '502': {
                title: 'Deserialization of Untrusted Data',
                description: 'The application deserializes untrusted data without sufficiently verifying that the resulting data will be valid.',
                severity: 'critical',
                cwe: 'CWE-502',
                owasp: 'A08:2021',
                mitigation: `1. Avoid Deserialization: Use safe data formats like JSON
2. Input Validation: Validate serialized data before deserialization
3. Integrity Checks: Use digital signatures or HMACs
4. Least Privilege: Run deserialization in restricted environments
5. Safe Libraries: Use serialization libraries with security features`,
                examples: [
                    'eval(untrustedData); // Extremely vulnerable',
                    'JSON.parse(untrustedData); // Safer but validate schema',
                    'pickle.loads(untrustedData); // Vulnerable in Python',
                    'const data = JSON.parse(input); validateSchema(data); // Safer approach'
                ],
                tags: ['deserialization', 'untrusted-data', 'object-injection', 'code-execution']
            },
            '94': {
                title: 'Code Injection',
                description: 'The software constructs all or part of a code segment using externally-influenced input but does not neutralize elements that could modify the syntax or behavior of the intended code segment.',
                severity: 'critical',
                cwe: 'CWE-94',
                owasp: 'A03:2021',
                mitigation: `1. Avoid Dynamic Code Execution: Never execute user-provided code
2. Input Validation: Strictly validate and sanitize all inputs
3. Sandboxing: Execute code in isolated, restricted environments
4. Use Safe APIs: Use APIs that don't allow code execution
5. Static Analysis: Use tools to detect code injection vulnerabilities`,
                examples: [
                    'eval("user_" + userInput); // Extremely vulnerable',
                    'new Function(userCode)(); // Dangerous',
                    'vm.runInNewContext(userCode); // Still risky',
                    '// Never execute user input as code'
                ],
                tags: ['code-injection', 'remote-code-execution', 'eval', 'function-constructor']
            },
            '95': {
                title: 'Improper Neutralization of Directives in Dynamically Evaluated Code (Eval Injection)',
                description: 'The software receives input from an upstream component, but it does not neutralize code syntax before using the input in a dynamic evaluation call.',
                severity: 'critical',
                cwe: 'CWE-95',
                owasp: 'A03:2021',
                mitigation: `1. Never Use eval(): Avoid eval() completely with user input
2. Use JSON.parse(): For data, use JSON.parse() instead of eval()
3. Template Sandboxing: Use template engines with automatic escaping
4. Content Security Policy: Implement CSP to prevent inline script execution
5. Input Validation: Validate and sanitize before any processing`,
                examples: [
                    'eval(req.body.expression); // Critical vulnerability',
                    'setTimeout(userInput, 1000); // Vulnerable',
                    'JSON.parse(userInput); // Safe for data',
                    'new Function("return " + userInput)(); // Still vulnerable'
                ],
                tags: ['eval-injection', 'code-injection', 'eval', 'dynamic-evaluation']
            },
            '117': {
                title: 'Improper Output Neutralization for Logs',
                description: 'The software does not neutralize or incorrectly neutralizes output that is written to logs.',
                severity: 'medium',
                cwe: 'CWE-117',
                mitigation: `1. Sanitize Log Input: Remove or escape special characters before logging
2. Structured Logging: Use structured logging libraries (Winston, Bunyan)
3. Limit Log Data: Don't log sensitive information
4. Validate Input: Validate before logging
5. Use Log Libraries: Use logging libraries with built-in sanitization`,
                examples: [
                    'console.log("User input: " + userInput); // Log injection risk',
                    'logger.info({userId: userId, action: action}); // Structured logging',
                    'console.log("Login: " + username.replace(/\\n/g, "")); // Sanitized',
                    'logger.info("User action", {sanitizedInput: sanitize(userInput)}); // Safe'
                ],
                tags: ['log-injection', 'logging', 'output-neutralization']
            },
            '200': {
                title: 'Information Exposure',
                description: 'The product exposes sensitive information to an actor that is not explicitly authorized to have access to that information.',
                severity: 'medium',
                cwe: 'CWE-200',
                owasp: 'A01:2021',
                mitigation: `1. Minimize Exposure: Only expose necessary information
2. Error Handling: Use generic error messages in production
3. Disable Debug Mode: Turn off debug/verbose modes in production
4. Access Controls: Implement proper access controls
5. Data Classification: Classify and protect sensitive data`,
                examples: [
                    'res.status(500).json({error: err.stack}); // Exposes stack trace',
                    'res.status(500).json({error: "Internal server error"}); // Generic message',
                    'console.log("Database password:", dbPassword); // Never log secrets',
                    'logger.debug("Config:", {sanitizedConfig}); // Safe debug logging'
                ],
                tags: ['information-disclosure', 'data-leakage', 'error-handling']
            },
            '269': {
                title: 'Improper Privilege Management',
                description: 'The software does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor.',
                severity: 'high',
                cwe: 'CWE-269',
                owasp: 'A01:2021',
                mitigation: `1. Least Privilege: Grant minimum necessary privileges
2. Role-Based Access Control: Implement RBAC
3. Regular Audits: Audit privilege assignments regularly
4. Privilege Escalation Controls: Prevent unauthorized elevation
5. Separation of Duties: Implement separation of duties`,
                examples: [
                    'if (user.isAdmin || user.isEditor) { allowAccess(); } // Too broad',
                    'if (hasPermission(user, "specific_action")) { allowAccess(); } // Better',
                    'db.grantAllPrivileges(user); // Dangerous',
                    'db.grantSpecificPrivileges(user, ["read", "write"]); // Controlled'
                ],
                tags: ['privilege-management', 'access-control', 'authorization']
            },
            '287': {
                title: 'Improper Authentication',
                description: 'When an actor claims to have a given identity, the software does not prove or insufficiently proves that the claim is correct.',
                severity: 'critical',
                cwe: 'CWE-287',
                owasp: 'A07:2021',
                mitigation: `1. Multi-Factor Authentication: Implement MFA
2. Strong Password Policy: Enforce strong passwords
3. Secure Session Management: Use secure, random session tokens
4. Rate Limiting: Implement rate limiting for auth attempts
5. Account Lockout: Lock accounts after failed attempts`,
                examples: [
                    'if (user.password === inputPassword) { login(); } // Plain text comparison',
                    'bcrypt.compare(inputPassword, user.hashedPassword); // Secure comparison',
                    'if (req.headers.user === "admin") { grantAccess(); } // Easily bypassed',
                    'passport.authenticate("local", {session: true}); // Proper authentication'
                ],
                tags: ['authentication', 'identity-verification', 'login']
            },
            '306': {
                title: 'Missing Authentication for Critical Function',
                description: 'The software does not perform authentication for a critical function, allowing unauthorized access.',
                severity: 'critical',
                cwe: 'CWE-306',
                owasp: 'A07:2021',
                mitigation: `1. Protect All Endpoints: Ensure all critical endpoints require authentication
2. Default Deny: Deny access by default
3. Middleware: Use authentication middleware
4. API Keys: Require API keys for API endpoints
5. Session Validation: Validate sessions on every request`,
                examples: [
                    'app.delete("/api/users/:id", deleteUser); // No auth check',
                    'app.delete("/api/users/:id", authMiddleware, deleteUser); // Protected',
                    'router.get("/admin", adminPanel); // Unprotected admin',
                    'router.get("/admin", requireAuth, requireAdmin, adminPanel); // Secured'
                ],
                tags: ['missing-authentication', 'unauthenticated-access', 'critical-function']
            },
            '327': {
                title: 'Use of Broken or Risky Cryptographic Algorithm',
                description: 'The use of a broken or risky cryptographic algorithm is an unnecessary risk that may result in the exposure of sensitive information.',
                severity: 'high',
                cwe: 'CWE-327',
                owasp: 'A02:2021',
                mitigation: `1. Use Modern Algorithms: Use AES-256, RSA-2048+, SHA-256+
2. Avoid Weak Algorithms: Never use MD5, SHA1, DES, RC4
3. Use Libraries: Use well-tested crypto libraries
4. Key Management: Implement proper key rotation
5. Stay Updated: Keep crypto libraries updated`,
                examples: [
                    'crypto.createHash("md5").update(password); // Weak, broken',
                    'crypto.createHash("sha256").update(password); // Better but use bcrypt for passwords',
                    'const cipher = crypto.createCipher("des", key); // Weak algorithm',
                    'const cipher = crypto.createCipheriv("aes-256-gcm", key, iv); // Strong'
                ],
                tags: ['weak-cryptography', 'broken-crypto', 'encryption']
            },
            '328': {
                title: 'Reversible One-Way Hash',
                description: 'The product uses a hashing algorithm that produces a hash value that can be used to determine the original input.',
                severity: 'high',
                cwe: 'CWE-328',
                owasp: 'A02:2021',
                mitigation: `1. Use Strong Hashing: Use bcrypt, Argon2, or PBKDF2 for passwords
2. Add Salt: Always use unique salts
3. Multiple Rounds: Use sufficient iteration counts
4. Avoid MD5/SHA1: Never use for passwords
5. Key Derivation: Use proper key derivation functions`,
                examples: [
                    'const hash = crypto.createHash("md5").update(password).digest("hex"); // Weak',
                    'const hash = crypto.createHash("sha1").update(password).digest("hex"); // Still weak',
                    'bcrypt.hash(password, 12); // Strong for passwords',
                    'crypto.pbkdf2Sync(password, salt, 100000, 64, "sha512"); // Strong KDF'
                ],
                tags: ['weak-hashing', 'password-hashing', 'cryptography']
            },
            '347': {
                title: 'Improper Verification of Cryptographic Signature',
                description: 'The software does not verify, or incorrectly verifies, the cryptographic signature for data.',
                severity: 'high',
                cwe: 'CWE-347',
                owasp: 'A02:2021',
                mitigation: `1. Verify Signatures: Always verify cryptographic signatures
2. Use Standard Libraries: Use well-tested signature verification libraries
3. Certificate Validation: Properly validate certificates
4. Reject Invalid: Reject data with invalid signatures
5. Timing-Safe Comparison: Use timing-safe comparison functions`,
                examples: [
                    'if (token.signature === expectedSignature) { } // Timing attack vulnerable',
                    'crypto.timingSafeEqual(Buffer.from(token.sig), Buffer.from(expected)); // Safe',
                    'jwt.verify(token, publicKey); // Proper JWT verification',
                    '// Always verify signatures before trusting signed data'
                ],
                tags: ['signature-verification', 'cryptography', 'jwt', 'certificates']
            }
        };

        const cweData = cweDatabase[cweId];
        if (!cweData) {
            return null;
        }

        return {
            id: `cwe-${cweId}`,
            title: cweData.title || `CWE-${cweId}`,
            description: cweData.description || 'No description available',
            severity: cweData.severity || 'medium',
            cwe: cweData.cwe || `CWE-${cweId}`,
            owasp: cweData.owasp,
            mitigation: cweData.mitigation || 'No mitigation information available',
            examples: cweData.examples || [],
            references: [
                `https://cwe.mitre.org/data/definitions/${cweId}.html`,
                `https://owasp.org/www-community/vulnerabilities/`
            ],
            lastUpdated: new Date().toISOString(),
            source: 'cwe',
            tags: cweData.tags || []
        };
    }

    async fetchOWASPTop10(): Promise<VulnerabilityData[]> {
        const cacheFile = path.join(this.dataPath, 'owasp-top10.json');
        
        if (this.isCacheValid(cacheFile)) {
            try {
                const cached = JSON.parse(await fsPromises.readFile(cacheFile, 'utf8'));
                this.logger.debug('Using cached OWASP Top 10 data');
                return cached;
            } catch (error) {
                this.logger.warn('Failed to read OWASP cache:', error);
            }
        }

        this.logger.info('Fetching fresh OWASP Top 10 data...');
        
        // OWASP Top 10 2021 data
        const owaspData: VulnerabilityData[] = [
            {
                id: 'owasp-a01-2021',
                title: 'A01:2021 – Broken Access Control',
                description: 'Access control enforces policy such that users cannot act outside of their intended permissions. Failures typically lead to unauthorized information disclosure, modification, or destruction of all data or performing a business function outside the user\'s limits.',
                severity: 'high',
                owasp: 'A01:2021',
                mitigation: `1. Implement proper authorization checks
2. Use principle of least privilege
3. Deny access by default
4. Log access control failures and alert admins
5. Rate limit API and controller access`,
                examples: [
                    'if (user.role !== "admin") throw new Error("Unauthorized"); // Proper check',
                    'app.get("/admin/*", requireAuth, requireAdmin); // Route-level protection',
                    'const data = await getUserData(req.user.id); // User can only access own data'
                ],
                references: ['https://owasp.org/Top10/A01_2021-Broken_Access_Control/'],
                lastUpdated: new Date().toISOString(),
                source: 'owasp',
                tags: ['access-control', 'authorization', 'permissions', 'owasp-top10']
            },
            {
                id: 'owasp-a02-2021',
                title: 'A02:2021 – Cryptographic Failures',
                description: 'Many web applications and APIs do not properly protect sensitive data. Attackers may steal or modify such weakly protected data to conduct credit card fraud, identity theft, or other crimes.',
                severity: 'high',
                owasp: 'A02:2021',
                mitigation: `1. Use strong encryption algorithms (AES-256, RSA-2048+)
2. Implement proper key management
3. Use HTTPS for all communications
4. Hash passwords with strong algorithms (bcrypt, Argon2)
5. Avoid deprecated cryptographic functions`,
                examples: [
                    'crypto.createHash("md5").update(password); // Weak, avoid',
                    'bcrypt.hash(password, 12); // Strong password hashing',
                    'crypto.randomBytes(32); // Secure random generation',
                    'https.createServer(tlsOptions, app); // Force HTTPS'
                ],
                references: ['https://owasp.org/Top10/A02_2021-Cryptographic_Failures/'],
                lastUpdated: new Date().toISOString(),
                source: 'owasp',
                tags: ['cryptography', 'encryption', 'data-protection', 'owasp-top10', 'https']
            },
            {
                id: 'owasp-a03-2021',
                title: 'A03:2021 – Injection',
                description: 'An application is vulnerable to attack when user-supplied data is not validated, filtered, or sanitized by the application.',
                severity: 'critical',
                owasp: 'A03:2021',
                cwe: 'CWE-79, CWE-89',
                mitigation: `1. Use parameterized queries and prepared statements
2. Validate input using positive allow-lists
3. Escape special characters for output contexts
4. Use SQL controls like LIMIT to prevent mass disclosure
5. Implement proper input validation and sanitization`,
                examples: [
                    'db.query(`SELECT * FROM users WHERE id = ${id}`); // SQL Injection risk',
                    'db.query("SELECT * FROM users WHERE id = ?", [id]); // Safe parameterized query',
                    'eval(userInput); // Code injection risk',
                    'DOMPurify.sanitize(userInput); // Safe HTML sanitization'
                ],
                references: ['https://owasp.org/Top10/A03_2021-Injection/'],
                lastUpdated: new Date().toISOString(),
                source: 'owasp',
                tags: ['injection', 'sql-injection', 'xss', 'code-injection', 'owasp-top10']
            },
            {
                id: 'owasp-a04-2021',
                title: 'A04:2021 – Insecure Design',
                description: 'Insecure design is a broad category representing different weaknesses in design and architectural flaws. It calls for more use of threat modeling, secure design patterns, and reference architectures.',
                severity: 'high',
                owasp: 'A04:2021',
                mitigation: `1. Establish and use a secure development lifecycle with AppSec professionals
2. Use threat modeling for critical authentication, access control, business logic, and key flows
3. Integrate security language and controls into user stories
4. Integrate plausibility checks at each tier of your application
5. Write unit and integration tests to validate that all critical flows are resistant to the threat model`,
                examples: [
                    '// Example: Password recovery without rate limiting',
                    'app.post("/reset-password", resetPassword); // No rate limit - credential stuffing risk',
                    'app.post("/reset-password", rateLimit({max: 3, windowMs: 3600000}), resetPassword); // Protected',
                    '// Example: Insecure state transitions',
                    'if (order.status === "pending") { order.status = req.body.status; } // Can skip payment'
                ],
                references: ['https://owasp.org/Top10/A04_2021-Insecure_Design/'],
                lastUpdated: new Date().toISOString(),
                source: 'owasp',
                tags: ['insecure-design', 'threat-modeling', 'security-architecture', 'owasp-top10']
            },
            {
                id: 'owasp-a05-2021',
                title: 'A05:2021 – Security Misconfiguration',
                description: 'Security misconfiguration is the most commonly seen issue, often resulting from insecure default configurations, incomplete or ad hoc configurations, open cloud storage, misconfigured HTTP headers, and verbose error messages.',
                severity: 'high',
                owasp: 'A05:2021',
                mitigation: `1. Remove unnecessary features, frameworks, documentation, and components
2. Implement a repeatable hardening process for fast, easy deployment of secured environments
3. Use a minimal platform without unnecessary features
4. Review and update configurations with security notes, updates, and patches
5. Use automated process to verify effectiveness of configurations`,
                examples: [
                    'app.use(express.json()); // Missing security headers',
                    'app.use(helmet()); // Proper security headers',
                    'if (process.env.NODE_ENV !== "production") { app.use(errorHandler); } // Debug mode check',
                    'res.header("X-Powered-By", "Express"); // Reveals technology stack - remove'
                ],
                references: ['https://owasp.org/Top10/A05_2021-Security_Misconfiguration/'],
                lastUpdated: new Date().toISOString(),
                source: 'owasp',
                tags: ['misconfiguration', 'default-credentials', 'security-headers', 'owasp-top10']
            },
            {
                id: 'owasp-a06-2021',
                title: 'A06:2021 – Vulnerable and Outdated Components',
                description: 'You are likely vulnerable if you do not know the versions of all components you use, if the software is vulnerable, unsupported, or out of date, or if you do not scan for vulnerabilities regularly.',
                severity: 'high',
                owasp: 'A06:2021',
                mitigation: `1. Remove unused dependencies, features, components, files, and documentation
2. Continuously inventory versions of client and server components and dependencies
3. Monitor sources like CVE and NVD for vulnerabilities
4. Use automated tools to check for outdated or insecure components
5. Obtain components from official sources over secure links`,
                examples: [
                    '// package.json with outdated dependencies',
                    '"dependencies": { "lodash": "4.17.15" } // Vulnerable to prototype pollution',
                    '"dependencies": { "lodash": "^4.17.21" } // Patched version',
                    'npm audit // Check for vulnerabilities',
                    'npm audit fix // Automatically fix vulnerabilities'
                ],
                references: ['https://owasp.org/Top10/A06_2021-Vulnerable_and_Outdated_Components/'],
                lastUpdated: new Date().toISOString(),
                source: 'owasp',
                tags: ['outdated-components', 'dependency-management', 'npm-audit', 'owasp-top10']
            },
            {
                id: 'owasp-a07-2021',
                title: 'A07:2021 – Identification and Authentication Failures',
                description: 'Confirmation of the user\'s identity, authentication, and session management is critical to protect against authentication-related attacks.',
                severity: 'high',
                owasp: 'A07:2021',
                mitigation: `1. Implement multi-factor authentication
2. Do not ship or deploy with default credentials
3. Implement weak password checks against common password lists
4. Align password length, complexity, and rotation policies with NIST 800-63b guidelines
5. Limit or increasingly delay failed login attempts`,
                examples: [
                    'if (username === "admin" && password === "admin") { } // Default credentials',
                    'bcrypt.compare(password, user.hashedPassword); // Proper password verification',
                    'const sessionId = Math.random().toString(); // Weak session ID',
                    'const sessionId = crypto.randomBytes(32).toString("hex"); // Strong session ID'
                ],
                references: ['https://owasp.org/Top10/A07_2021-Identification_and_Authentication_Failures/'],
                lastUpdated: new Date().toISOString(),
                source: 'owasp',
                tags: ['authentication', 'session-management', 'password-security', 'owasp-top10']
            },
            {
                id: 'owasp-a08-2021',
                title: 'A08:2021 – Software and Data Integrity Failures',
                description: 'Software and data integrity failures relate to code and infrastructure that does not protect against integrity violations.',
                severity: 'critical',
                owasp: 'A08:2021',
                mitigation: `1. Use digital signatures to verify software or data is from expected source
2. Ensure libraries and dependencies are consuming trusted repositories
3. Use software supply chain security tools like OWASP Dependency Check
4. Ensure CI/CD pipeline has proper segregation, configuration, and access control
5. Ensure unsigned or unencrypted serialized data is not sent to untrusted clients`,
                examples: [
                    '<script src="https://cdn.example.com/lib.js"></script> // No integrity check',
                    '<script src="https://cdn.example.com/lib.js" integrity="sha384-..." crossorigin="anonymous"></script> // SRI',
                    'eval(localStorage.getItem("userData")); // Insecure deserialization',
                    'const data = JSON.parse(verifySignature(signedData)); // Verified data'
                ],
                references: ['https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/'],
                lastUpdated: new Date().toISOString(),
                source: 'owasp',
                tags: ['data-integrity', 'supply-chain', 'deserialization', 'ci-cd', 'owasp-top10']
            },
            {
                id: 'owasp-a09-2021',
                title: 'A09:2021 – Security Logging and Monitoring Failures',
                description: 'Without logging and monitoring, breaches cannot be detected. Insufficient logging, detection, monitoring, and active response occurs any time.',
                severity: 'medium',
                owasp: 'A09:2021',
                mitigation: `1. Ensure all login, access control, and server-side input validation failures can be logged
2. Ensure logs are generated in a format that log management solutions can easily consume
3. Ensure log data is encoded correctly to prevent injections or attacks
4. Ensure high-value transactions have an audit trail with integrity controls
5. Establish effective monitoring and alerting`,
                examples: [
                    '// No logging',
                    'try { riskyOperation(); } catch(e) { } // Silent failure',
                    '// Proper logging',
                    'logger.error("Failed login attempt", {username, ip, timestamp}); // Structured log',
                    'logger.info("High-value transaction", {userId, amount, timestamp}); // Audit trail'
                ],
                references: ['https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/'],
                lastUpdated: new Date().toISOString(),
                source: 'owasp',
                tags: ['logging', 'monitoring', 'incident-detection', 'audit-trail', 'owasp-top10']
            },
            {
                id: 'owasp-a10-2021',
                title: 'A10:2021 – Server-Side Request Forgery (SSRF)',
                description: 'SSRF flaws occur whenever a web application is fetching a remote resource without validating the user-supplied URL. It allows an attacker to coerce the application to send a crafted request to an unexpected destination.',
                severity: 'high',
                owasp: 'A10:2021',
                mitigation: `1. Sanitize and validate all client-supplied input data
2. Enforce URL schema, port, and destination with a positive allow list
3. Do not send raw responses to clients
4. Disable HTTP redirections
5. Use network segregation to reduce the impact of SSRF`,
                examples: [
                    'const response = await fetch(req.body.url); // SSRF vulnerability',
                    'if (!allowedDomains.includes(new URL(url).hostname)) throw new Error(); // Whitelist check',
                    'axios.get(userProvidedUrl); // Dangerous - can access internal services',
                    'axios.get(userProvidedUrl, {maxRedirects: 0, timeout: 5000}); // Safer with limits'
                ],
                references: ['https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_(SSRF)/'],
                lastUpdated: new Date().toISOString(),
                source: 'owasp',
                tags: ['ssrf', 'url-validation', 'request-forgery', 'owasp-top10']
            }
        ];

        // Cache the results
        try {
            await fsPromises.writeFile(cacheFile, JSON.stringify(owaspData, null, 2));
        } catch (error) {
            this.logger.warn('Failed to cache OWASP data:', error);
        }

        return owaspData;
    }

    async fetchLatestCVEs(limit: number = 50): Promise<VulnerabilityData[]> {
        const cacheFile = path.join(this.dataPath, 'latest-cves.json');
        
        if (this.isCacheValid(cacheFile)) {
            try {
                const cached = JSON.parse(await fsPromises.readFile(cacheFile, 'utf8'));
                this.logger.debug('Using cached CVE data');
                return cached;
            } catch (error) {
                this.logger.warn('Failed to read CVE cache:', error);
            }
        }

        this.logger.info('Fetching latest CVE data from NVD...');
        
        try {
            // Use NVD 2.0 API
            const url = `https://services.nvd.nist.gov/rest/json/cves/2.0?resultsPerPage=${limit}&startIndex=0`;
            const response = await this.fetchWithTimeout(url, 45000);
            const data = JSON.parse(response);

            const vulnerabilities: VulnerabilityData[] = [];

            for (const item of data.vulnerabilities || []) {
                const cve = item.cve;
                if (!cve) {
                    continue;
                }

                const description = cve.descriptions?.find((d: any) => d.lang === 'en')?.value || 'No description available';
                const cvssScore = cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore || 0;
                const severity = this.cvssToSeverity(cvssScore);
                
                const weakness = cve.weaknesses?.[0]?.description?.find((d: any) => d.lang === 'en')?.value;
                const cweId = weakness?.match(/CWE-(\d+)/)?.[0];

                vulnerabilities.push({
                    id: `cve-${cve.id}`,
                    title: `${cve.id} - Security Vulnerability`,
                    description: description.substring(0, 500) + (description.length > 500 ? '...' : ''),
                    severity: severity,
                    cve: cve.id,
                    cwe: cweId,
                    mitigation: 'Refer to vendor advisories and apply security patches immediately.',
                    examples: [],
                    references: cve.references?.map((ref: any) => ref.url) || [],
                    lastUpdated: new Date().toISOString(),
                    source: 'nvd',
                    tags: ['cve', 'vulnerability', 'security-advisory']
                });
            }

            // Cache the results
            try {
                await fsPromises.writeFile(cacheFile, JSON.stringify(vulnerabilities, null, 2));
            } catch (error) {
                this.logger.warn('Failed to cache CVE data:', error);
            }

            return vulnerabilities;

        } catch (error) {
            this.logger.error('Failed to fetch CVE data:', error);
            throw error;
        }
    }

    private cvssToSeverity(score: number): 'critical' | 'high' | 'medium' | 'low' {
        if (score >= 9.0) {
            return 'critical';
        }
        if (score >= 7.0) {
            return 'high';
        }
        if (score >= 4.0) {
            return 'medium';
        }
        return 'low';
    }

    async fetchJavaScriptVulnerabilities(): Promise<VulnerabilityData[]> {
        const cacheFile = path.join(this.dataPath, 'js-vulnerabilities.json');
        
        if (this.isCacheValid(cacheFile)) {
            try {
                const cached = JSON.parse(await fsPromises.readFile(cacheFile, 'utf8'));
                this.logger.debug('Using cached JavaScript vulnerability data');
                return cached;
            } catch (error) {
                this.logger.warn('Failed to read JavaScript vulnerability cache:', error);
            }
        }

        this.logger.info('Fetching JavaScript-specific vulnerability data...');

        const jsVulnerabilities: VulnerabilityData[] = [];

        // Fetch from multiple sources
        try {
            // 1. Fetch from GitHub Security Advisories for JavaScript/TypeScript
            const githubAdvisories = await this.fetchGitHubSecurityAdvisories();
            jsVulnerabilities.push(...githubAdvisories);

            // 2. Fetch from npm advisory database
            const npmAdvisories = await this.fetchNPMAdvisories();
            jsVulnerabilities.push(...npmAdvisories);

        } catch (error) {
            this.logger.error('Error fetching real-time JS vulnerabilities:', error);
            // Fallback to curated data if API calls fail
            this.logger.info('Using fallback curated JavaScript vulnerability data');
        }

        // Add curated JavaScript/TypeScript specific vulnerabilities as baseline
        const curatedVulnerabilities: VulnerabilityData[] = [
            {
                id: 'js-prototype-pollution',
                title: 'Prototype Pollution',
                description: 'Prototype pollution is a vulnerability that enables attackers to exploit JavaScript\'s prototype inheritance mechanism to inject properties into existing JavaScript language construct prototypes.',
                severity: 'high',
                cwe: 'CWE-1321',
                owasp: 'A06:2021',
                mitigation: `1. Input Validation: Validate object keys before assignment
2. Use Map: Use Map objects instead of plain objects for user data
3. Object.create(null): Create objects without prototype chain
4. Freeze Prototype: Use Object.freeze(Object.prototype)
5. Schema Validation: Implement strict schema validation`,
                examples: [
                    'obj[userKey] = userValue; // Vulnerable if userKey is "__proto__"',
                    'if (["__proto__", "constructor", "prototype"].includes(userKey)) return; // Protection',
                    'const safeObj = Object.create(null); safeObj[userKey] = userValue; // Safe',
                    'const map = new Map(); map.set(userKey, userValue); // Safe alternative'
                ],
                references: [
                    'https://owasp.org/www-community/vulnerabilities/Prototype_Pollution',
                    'https://github.com/HoLyVieR/prototype-pollution-nsec18'
                ],
                lastUpdated: new Date().toISOString(),
                source: 'custom',
                tags: ['prototype-pollution', 'javascript', 'object-manipulation', 'inheritance']
            },
            {
                id: 'js-regex-dos',
                title: 'Regular Expression Denial of Service (ReDoS)',
                description: 'ReDoS attacks leverage the fact that most Regular Expression implementations may reach extreme situations that cause them to work very slowly (exponentially related to input size).',
                severity: 'medium',
                cwe: 'CWE-1333',
                mitigation: `1. Avoid Nested Quantifiers: Don't use patterns like (a+)+
2. Timeout Limits: Implement regex execution timeouts
3. Input Length Limits: Limit input string length
4. Safe Patterns: Use atomic groups or possessive quantifiers
5. Testing: Test regex patterns with long inputs`,
                examples: [
                    '/^(a+)+$/.test(userInput); // Vulnerable to ReDoS',
                    '/^a+$/.test(userInput); // Safe pattern',
                    'const timeoutRegex = (pattern, input, timeout = 1000) => { /* implementation */ }; // Safe approach',
                    'if (userInput.length > 1000) throw new Error("Input too long"); // Length protection'
                ],
                references: [
                    'https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS',
                    'https://github.com/jagracey/RegEx-DoS'
                ],
                lastUpdated: new Date().toISOString(),
                source: 'custom',
                tags: ['redos', 'regex', 'denial-of-service', 'performance', 'javascript']
            },
            {
                id: 'js-eval-injection',
                title: 'Code Injection via eval()',
                description: 'Using eval() with user-controlled input can lead to arbitrary code execution, allowing attackers to run malicious JavaScript code.',
                severity: 'critical',
                cwe: 'CWE-95',
                owasp: 'A03:2021',
                mitigation: `1. Avoid eval(): Never use eval() with user input
2. Use JSON.parse(): For data parsing, use JSON.parse() instead
3. Function Constructor: Avoid new Function() with user input
4. Template Literals: Don't use template literals with user input
5. Safe Alternatives: Use proper parsing libraries`,
                examples: [
                    'eval(userInput); // Extremely dangerous',
                    'new Function(userInput)(); // Also dangerous',
                    'JSON.parse(userInput); // Safe for data',
                    'const parser = new DOMParser(); parser.parseFromString(userInput, "text/xml"); // Safe parsing'
                ],
                references: [
                    'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#never_use_eval!',
                    'https://owasp.org/www-community/attacks/Code_Injection'
                ],
                lastUpdated: new Date().toISOString(),
                source: 'custom',
                tags: ['eval', 'code-injection', 'javascript', 'arbitrary-code-execution']
            }
        ];

        // Combine real-time data with curated baseline
        jsVulnerabilities.push(...curatedVulnerabilities);

        // Deduplicate by ID
        const uniqueVulns = Array.from(
            new Map(jsVulnerabilities.map(v => [v.id, v])).values()
        );

        // Cache the results
        try {
            await fsPromises.writeFile(cacheFile, JSON.stringify(uniqueVulns, null, 2));
        } catch (error) {
            this.logger.warn('Failed to cache JavaScript vulnerability data:', error);
        }

        return uniqueVulns;
    }

    private async fetchGitHubSecurityAdvisories(): Promise<VulnerabilityData[]> {
        try {
            // GitHub Security Advisory API (public, no auth needed for basic queries)
            // We'll search for JavaScript/TypeScript ecosystem advisories
            const query = `ecosystem:npm severity:high,critical`;
            const url = `https://api.github.com/advisories?per_page=20&ecosystem=npm`;
            
            const response = await this.fetchWithTimeout(url, 30000);
            const advisories = JSON.parse(response);

            return advisories.map((advisory: any) => {
                const severity = this.mapGitHubSeverity(advisory.severity);
                
                return {
                    id: `github-${advisory.ghsa_id}`,
                    title: advisory.summary || 'Security Advisory',
                    description: advisory.description || 'No description available',
                    severity: severity,
                    cve: advisory.cve_id || undefined,
                    cwe: advisory.cwe_ids?.[0] || undefined,
                    mitigation: `Update affected packages. ${advisory.summary}`,
                    examples: [],
                    references: [
                        advisory.html_url,
                        ...(advisory.references || []).map((ref: any) => ref.url)
                    ].filter(Boolean),
                    lastUpdated: advisory.updated_at || new Date().toISOString(),
                    source: 'custom',
                    tags: ['github-advisory', 'npm', 'javascript', ...(advisory.cwe_ids || [])]
                };
            });
        } catch (error) {
            this.logger.warn('Failed to fetch GitHub Security Advisories:', error);
            return [];
        }
    }

    private async fetchNPMAdvisories(): Promise<VulnerabilityData[]> {
        try {
            // npm public registry audit endpoint
            // This is a simplified approach - in production you'd want to audit specific packages
            // For now, we'll fetch known high-severity npm vulnerabilities from the registry
            
            // Alternative: Use Snyk's public vulnerability database
            const url = 'https://security.snyk.io/vuln/npm';
            
            // Note: Snyk requires parsing HTML or using their API (which needs auth)
            // For a more robust solution, consider:
            // 1. GitHub Advisory Database API (implemented above)
            // 2. OSV.dev API for npm packages
            // 3. npm audit API (requires package.json context)
            
            // For now, we'll use OSV.dev which has a public API
            return await this.fetchOSVVulnerabilities();
            
        } catch (error) {
            this.logger.warn('Failed to fetch npm advisories:', error);
            return [];
        }
    }

    private async fetchOSVVulnerabilities(): Promise<VulnerabilityData[]> {
        try {
            // OSV.dev has a public API for vulnerability data
            // Query for npm ecosystem vulnerabilities
            const url = 'https://api.osv.dev/v1/query';
            
            const requestBody = JSON.stringify({
                package: {
                    ecosystem: 'npm'
                },
                version: '' // We want general vulnerabilities, not package-specific
            });

            // Note: OSV API requires POST, but for general queries we can use their web endpoint
            // For a production implementation, you'd want to:
            // 1. Make POST requests with specific package queries
            // 2. Parse responses properly
            // 3. Handle pagination
            
            // Fallback: Return common npm vulnerability patterns
            return this.getCommonNPMVulnerabilityPatterns();
            
        } catch (error) {
            this.logger.warn('Failed to fetch OSV vulnerabilities:', error);
            return [];
        }
    }

    private getCommonNPMVulnerabilityPatterns(): VulnerabilityData[] {
        // Based on real npm security advisories and common patterns
        return [
            {
                id: 'npm-dependency-confusion',
                title: 'Dependency Confusion Attack',
                description: 'Dependency confusion attacks occur when an attacker publishes a malicious package with the same name as a private package to a public registry, potentially leading to code execution.',
                severity: 'high',
                cwe: 'CWE-829',
                mitigation: `1. Use scoped packages (@org/package-name)
2. Configure .npmrc to use private registry
3. Enable package-lock.json and verify integrity
4. Use npm audit and npm audit signatures
5. Implement allowlists for approved packages`,
                examples: [
                    '// .npmrc - Configure registry priority',
                    '@mycompany:registry=https://private-registry.company.com',
                    '// package.json - Use scoped packages',
                    '"dependencies": { "@mycompany/internal-package": "^1.0.0" }'
                ],
                references: [
                    'https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610',
                    'https://github.blog/2021-02-12-avoiding-npm-substitution-attacks/'
                ],
                lastUpdated: new Date().toISOString(),
                source: 'custom',
                tags: ['npm', 'supply-chain', 'dependency-confusion', 'package-management']
            },
            {
                id: 'npm-typosquatting',
                title: 'Typosquatting / Package Name Confusion',
                description: 'Attackers publish packages with names similar to popular packages, hoping developers will accidentally install the malicious version.',
                severity: 'medium',
                cwe: 'CWE-494',
                mitigation: `1. Double-check package names before installation
2. Use npm audit and security tools
3. Review package source and maintainers
4. Enable 2FA for npm publishing
5. Use package lock files`,
                examples: [
                    '// Malicious: npm install cross-env (note the typo)',
                    '// Legitimate: npm install cross-env',
                    '// Always verify: npm info <package-name>',
                    '// Check downloads: npm info <package-name> downloads'
                ],
                references: [
                    'https://blog.npmjs.org/post/163723642530/crossenv-malware-on-the-npm-registry',
                    'https://snyk.io/blog/typosquatting-attacks/'
                ],
                lastUpdated: new Date().toISOString(),
                source: 'custom',
                tags: ['npm', 'typosquatting', 'supply-chain', 'social-engineering']
            },
            {
                id: 'npm-malicious-packages',
                title: 'Malicious Package Installation',
                description: 'Malicious packages may contain backdoors, crypto miners, credential stealers, or other malicious code that executes during installation or runtime.',
                severity: 'critical',
                cwe: 'CWE-506',
                mitigation: `1. Review package source code before installation
2. Check package reputation (downloads, maintainers, age)
3. Use npm audit regularly
4. Implement Software Composition Analysis (SCA)
5. Use tools like Socket.dev or Snyk`,
                examples: [
                    '// Check package before install',
                    'npm info <package-name>',
                    '// Audit dependencies',
                    'npm audit',
                    '// Use SCA tools',
                    'npx socket-cli audit'
                ],
                references: [
                    'https://socket.dev/npm/package/overview',
                    'https://blog.sonatype.com/npm-malware-detection'
                ],
                lastUpdated: new Date().toISOString(),
                source: 'custom',
                tags: ['npm', 'malware', 'supply-chain', 'backdoor']
            }
        ];
    }

    private mapGitHubSeverity(severity: string): 'critical' | 'high' | 'medium' | 'low' {
        const lower = severity?.toLowerCase() || 'medium';
        if (lower === 'critical') {return 'critical';}
        if (lower === 'high') {return 'high';}
        if (lower === 'moderate' || lower === 'medium') {return 'medium';}
        return 'low';
    }

    async updateAllVulnerabilityData(): Promise<{
        cwe: VulnerabilityData[];
        owasp: VulnerabilityData[];
        cves: VulnerabilityData[];
        javascript: VulnerabilityData[];
        total: number;
    }> {
        const results = {
            cwe: [] as VulnerabilityData[],
            owasp: [] as VulnerabilityData[],
            cves: [] as VulnerabilityData[],
            javascript: [] as VulnerabilityData[],
            total: 0
        };

        try {
            // Fetch data from all sources
            const [cweData, owaspData, cveData, jsData] = await Promise.allSettled([
                this.fetchCWEData(),
                this.fetchOWASPTop10(),
                this.fetchLatestCVEs(100), // Fetch 100 latest CVEs for better coverage
                this.fetchJavaScriptVulnerabilities()
            ]);

            if (cweData.status === 'fulfilled') {
                results.cwe = cweData.value;
            } else {
                this.logger.error('Failed to fetch CWE data:', cweData.reason);
            }

            if (owaspData.status === 'fulfilled') {
                results.owasp = owaspData.value;
            } else {
                this.logger.error('Failed to fetch OWASP data:', owaspData.reason);
            }

            if (cveData.status === 'fulfilled') {
                results.cves = cveData.value;
            } else {
                this.logger.error('Failed to fetch CVE data:', cveData.reason);
            }

            if (jsData.status === 'fulfilled') {
                results.javascript = jsData.value;
            } else {
                this.logger.error('Failed to fetch JavaScript vulnerability data:', jsData.reason);
            }

            results.total = results.cwe.length + results.owasp.length + results.cves.length + results.javascript.length;

            return results;

        } catch (error) {
            this.logger.error('Error updating vulnerability data:', error);
            throw error;
        }
    }

    async getAllCachedData(): Promise<VulnerabilityData[]> {
        const allData: VulnerabilityData[] = [];
        const cacheFiles = [
            'cwe-data.json',
            'owasp-top10.json',
            'latest-cves.json',
            'js-vulnerabilities.json'
        ];

        for (const file of cacheFiles) {
            const filePath = path.join(this.dataPath, file);
            if (fs.existsSync(filePath)) {
                try {
                    const data = JSON.parse(await fsPromises.readFile(filePath, 'utf8'));
                    allData.push(...data);
                } catch (error) {
                    this.logger.warn(`Failed to read cached data from ${file}:`, error);
                }
            }
        }

        return allData;
    }

    async clearCache(): Promise<void> {
        const cacheFiles = [
            'cwe-data.json',
            'owasp-top10.json',
            'latest-cves.json',
            'js-vulnerabilities.json'
        ];

        for (const file of cacheFiles) {
            const filePath = path.join(this.dataPath, file);
            if (fs.existsSync(filePath)) {
                try {
                    await fsPromises.unlink(filePath);
                } catch (error) {
                    this.logger.warn(`Failed to delete cache file ${file}:`, error);
                }
            }
        }
    }

    getCacheInfo(): { file: string; exists: boolean; age: number; size: number }[] {
        const cacheFiles = [
            'cwe-data.json',
            'owasp-top10.json', 
            'latest-cves.json',
            'js-vulnerabilities.json'
        ];

        return cacheFiles.map(file => {
            const filePath = path.join(this.dataPath, file);
            const exists = fs.existsSync(filePath);
            
            if (exists) {
                const stats = fs.statSync(filePath);
                return {
                    file,
                    exists,
                    age: Date.now() - stats.mtime.getTime(),
                    size: stats.size
                };
            } else {
                return {
                    file,
                    exists,
                    age: 0,
                    size: 0
                };
            }
        });
    }
}