import * as assert from 'assert';
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { VulnerabilityDataManager } from '../vulnerabilityDataManager';

suite('VulnerabilityDataManager Test Suite', () => {
    let dataManager: VulnerabilityDataManager;
    let context: vscode.ExtensionContext;
    let testWorkspaceDir: string;

    suiteSetup(async () => {
        // Create mock extension context for testing
        testWorkspaceDir = path.join(__dirname, '..', '..', 'test-workspace-vulnmgr');
        if (!fs.existsSync(testWorkspaceDir)) {
            fs.mkdirSync(testWorkspaceDir, { recursive: true });
        }

        // Create required directories
        const vulnerabilityDataDir = path.join(testWorkspaceDir, 'vulnerability-data');
        if (!fs.existsSync(vulnerabilityDataDir)) {
            fs.mkdirSync(vulnerabilityDataDir, { recursive: true });
        }

        context = {
            extensionPath: testWorkspaceDir,
            subscriptions: [],
            workspaceState: {
                get: () => undefined,
                update: async () => {},
                keys: () => []
            },
            globalState: {
                get: () => undefined,
                update: async () => {},
                keys: () => [],
                setKeysForSync: () => {}
            },
            asAbsolutePath: (relativePath: string) => path.join(testWorkspaceDir, relativePath),
            storageUri: vscode.Uri.file(path.join(testWorkspaceDir, 'storage')),
            storagePath: path.join(testWorkspaceDir, 'storage'),
            globalStorageUri: vscode.Uri.file(path.join(testWorkspaceDir, 'global-storage')),
            globalStoragePath: path.join(testWorkspaceDir, 'global-storage'),
            logUri: vscode.Uri.file(path.join(testWorkspaceDir, 'logs')),
            logPath: path.join(testWorkspaceDir, 'logs'),
            extensionUri: vscode.Uri.file(testWorkspaceDir),
            environmentVariableCollection: {} as any,
            extensionMode: vscode.ExtensionMode.Test,
            secrets: {} as any,
            extension: {} as any,
            languageModelAccessInformation: {} as any
        } as vscode.ExtensionContext;

        dataManager = new VulnerabilityDataManager(context);
    });

    suiteTeardown(() => {
        // Clean up test workspace
        if (fs.existsSync(testWorkspaceDir)) {
            fs.rmSync(testWorkspaceDir, { recursive: true, force: true });
        }
    });

    suite('CWE Data Tests', () => {
        test('Should fetch CWE data', async function() {
            this.timeout(30000); // 30 second timeout for network call

            const cweData = await dataManager.fetchCWEData();

            assert.ok(cweData, 'CWE data should be returned');
            assert.ok(cweData.length > 0, 'CWE data should not be empty');

            // Verify data structure
            const firstEntry = cweData[0];
            assert.ok(firstEntry.id, 'Entry should have an id');
            assert.ok(firstEntry.title, 'Entry should have a title');
            assert.ok(firstEntry.description, 'Entry should have a description');
            assert.ok(firstEntry.severity, 'Entry should have a severity');
            assert.ok(firstEntry.mitigation, 'Entry should have mitigation');
            assert.ok(firstEntry.source === 'cwe', 'Source should be cwe');

            console.log(`✅ Fetched ${cweData.length} CWE entries`);
        });

        test('CWE data should have expected entries', async function() {
            this.timeout(30000);

            const cweData = await dataManager.fetchCWEData();

            // Check for common CWEs
            const cwe79 = cweData.find(v => v.cwe === 'CWE-79');
            assert.ok(cwe79, 'Should include CWE-79 (XSS)');

            const cwe89 = cweData.find(v => v.cwe === 'CWE-89');
            assert.ok(cwe89, 'Should include CWE-89 (SQL Injection)');

            console.log('✅ Expected CWE entries found');
        });

        test('CWE entries should have examples', async function() {
            this.timeout(30000);

            const cweData = await dataManager.fetchCWEData();

            const entriesWithExamples = cweData.filter(v => v.examples.length > 0);
            assert.ok(entriesWithExamples.length > 0, 'At least some entries should have examples');

            console.log(`✅ ${entriesWithExamples.length}/${cweData.length} entries have examples`);
        });
    });

    suite('OWASP Top 10 Tests', () => {
        test('Should fetch OWASP Top 10 data', async function() {
            this.timeout(30000);

            const owaspData = await dataManager.fetchOWASPTop10();

            assert.ok(owaspData, 'OWASP data should be returned');
            assert.ok(owaspData.length > 0, 'OWASP data should not be empty');

            // Verify data structure
            const firstEntry = owaspData[0];
            assert.ok(firstEntry.id, 'Entry should have an id');
            assert.ok(firstEntry.title, 'Entry should have a title');
            assert.ok(firstEntry.owasp, 'Entry should have OWASP reference');
            assert.ok(firstEntry.source === 'owasp', 'Source should be owasp');

            console.log(`✅ Fetched ${owaspData.length} OWASP entries`);
        });

        test('Should include A01, A02, A03 from 2021', async function() {
            this.timeout(30000);

            const owaspData = await dataManager.fetchOWASPTop10();

            const a01 = owaspData.find(v => v.owasp === 'A01:2021');
            const a02 = owaspData.find(v => v.owasp === 'A02:2021');
            const a03 = owaspData.find(v => v.owasp === 'A03:2021');

            assert.ok(a01, 'Should include A01:2021');
            assert.ok(a02, 'Should include A02:2021');
            assert.ok(a03, 'Should include A03:2021');

            console.log('✅ OWASP Top 10 2021 entries found');
        });
    });

    suite('NVD CVE Tests', () => {
        test('Should fetch latest CVEs from NVD', async function() {
            this.timeout(60000); // 60 seconds for NVD API

            const cveData = await dataManager.fetchLatestCVEs(10);

            assert.ok(cveData, 'CVE data should be returned');
            assert.ok(cveData.length > 0, 'CVE data should not be empty');

            // Verify data structure
            const firstEntry = cveData[0];
            assert.ok(firstEntry.id, 'Entry should have an id');
            assert.ok(firstEntry.cve, 'Entry should have CVE reference');
            assert.ok(firstEntry.source === 'nvd', 'Source should be nvd');

            console.log(`✅ Fetched ${cveData.length} CVE entries from NVD`);
        });

        test('CVE entries should have severity', async function() {
            this.timeout(60000);

            const cveData = await dataManager.fetchLatestCVEs(10);

            const validSeverities = ['critical', 'high', 'medium', 'low'];
            cveData.forEach(entry => {
                assert.ok(
                    validSeverities.includes(entry.severity),
                    `Severity should be one of: ${validSeverities.join(', ')}`
                );
            });

            console.log('✅ All CVE entries have valid severity');
        });

        test('CVE entries should have references', async function() {
            this.timeout(60000);

            const cveData = await dataManager.fetchLatestCVEs(10);

            const entriesWithRefs = cveData.filter(v => v.references.length > 0);
            assert.ok(entriesWithRefs.length > 0, 'At least some CVEs should have references');

            console.log(`✅ ${entriesWithRefs.length}/${cveData.length} CVE entries have references`);
        });
    });

    suite('JavaScript Vulnerabilities Tests', () => {
        test('Should fetch JavaScript-specific vulnerabilities', async function() {
            this.timeout(60000);

            const jsVulns = await dataManager.fetchJavaScriptVulnerabilities();

            assert.ok(jsVulns, 'JavaScript vulnerabilities should be returned');
            assert.ok(jsVulns.length > 0, 'JavaScript vulnerabilities should not be empty');

            console.log(`✅ Fetched ${jsVulns.length} JavaScript vulnerability entries`);
        });

        test('Should include prototype pollution', async function() {
            this.timeout(60000);

            const jsVulns = await dataManager.fetchJavaScriptVulnerabilities();

            const prototypePollution = jsVulns.find(v =>
                v.tags.includes('prototype-pollution') ||
                v.title.toLowerCase().includes('prototype')
            );

            assert.ok(prototypePollution, 'Should include prototype pollution vulnerability');
            console.log('✅ Prototype pollution vulnerability found');
        });

        test('Should include ReDoS', async function() {
            this.timeout(60000);

            const jsVulns = await dataManager.fetchJavaScriptVulnerabilities();

            const redos = jsVulns.find(v =>
                v.tags.includes('redos') ||
                v.title.toLowerCase().includes('redos') ||
                v.title.toLowerCase().includes('regex')
            );

            assert.ok(redos, 'Should include ReDoS vulnerability');
            console.log('✅ ReDoS vulnerability found');
        });

        test('Should include eval injection', async function() {
            this.timeout(60000);

            const jsVulns = await dataManager.fetchJavaScriptVulnerabilities();

            const evalInjection = jsVulns.find(v =>
                v.tags.includes('eval') ||
                v.title.toLowerCase().includes('eval')
            );

            assert.ok(evalInjection, 'Should include eval injection vulnerability');
            console.log('✅ eval injection vulnerability found');
        });
    });

    suite('Comprehensive Update Tests', () => {
        test('Should fetch from all sources', async function() {
            this.timeout(120000); // 2 minutes for all sources

            const result = await dataManager.updateAllVulnerabilityData();

            assert.ok(result, 'Result should be returned');
            assert.ok(result.total > 0, 'Total should be greater than 0');

            // Verify all sources returned data
            assert.ok(result.cwe.length > 0, 'CWE data should be fetched');
            assert.ok(result.owasp.length > 0, 'OWASP data should be fetched');
            assert.ok(result.cves.length > 0, 'CVE data should be fetched');
            assert.ok(result.javascript.length > 0, 'JavaScript vulnerabilities should be fetched');

            console.log(`✅ Fetched from all sources:
                - CWE: ${result.cwe.length}
                - OWASP: ${result.owasp.length}
                - CVEs: ${result.cves.length}
                - JavaScript: ${result.javascript.length}
                - Total: ${result.total}`);
        });

        test('Total should match sum of sources', async function() {
            this.timeout(120000);

            const result = await dataManager.updateAllVulnerabilityData();

            const sum = result.cwe.length +
                       result.owasp.length +
                       result.cves.length +
                       result.javascript.length;

            assert.strictEqual(result.total, sum, 'Total should equal sum of all sources');
            console.log('✅ Total count matches sum of sources');
        });
    });

    suite('Cache Tests', () => {
        test('Should use cache on second fetch', async function() {
            this.timeout(60000);

            // Clear cache first to ensure we're testing from fresh state
            await dataManager.clearCache();

            const start1 = Date.now();
            await dataManager.fetchCWEData();
            const duration1 = Date.now() - start1;

            const start2 = Date.now();
            await dataManager.fetchCWEData();
            const duration2 = Date.now() - start2;

            // Second fetch should be significantly faster (cached)
            // Use more lenient threshold since curated data is fast even on first fetch
            const isSignificantlyFaster = duration2 < duration1 / 1.5 || duration2 < 50;
            assert.ok(isSignificantlyFaster, `Second fetch should be faster or very fast (${duration2}ms vs ${duration1}ms)`);

            console.log(`✅ Cache working:
                - First fetch: ${duration1}ms
                - Second fetch (cached): ${duration2}ms
                - Speed improvement: ${duration2 > 0 ? Math.round(duration1 / duration2) : 'N/A'}x`);
        });

        test('Should provide cache info', () => {
            const cacheInfo = dataManager.getCacheInfo();

            assert.ok(cacheInfo, 'Cache info should be returned');
            assert.ok(Array.isArray(cacheInfo), 'Cache info should be an array');
            assert.ok(cacheInfo.length > 0, 'Cache info should not be empty');

            console.log('✅ Cache info available:');
            cacheInfo.forEach(info => {
                console.log(`   ${info.file}: ${info.exists ? 'cached' : 'not cached'}`);
            });
        });

        test('Should be able to clear cache', async () => {
            await dataManager.clearCache();

            const cacheInfo = dataManager.getCacheInfo();
            const cachedFiles = cacheInfo.filter(info => info.exists);

            assert.strictEqual(cachedFiles.length, 0, 'All cache files should be cleared');
            console.log('✅ Cache cleared successfully');
        });
    });

    suite('Data Quality Tests', () => {
        test('All entries should have required fields', async function() {
            this.timeout(120000);

            const result = await dataManager.updateAllVulnerabilityData();
            const allData = [
                ...result.cwe,
                ...result.owasp,
                ...result.cves,
                ...result.javascript
            ];

            allData.forEach(entry => {
                assert.ok(entry.id, 'Entry should have id');
                assert.ok(entry.title, 'Entry should have title');
                assert.ok(entry.description, 'Entry should have description');
                assert.ok(entry.severity, 'Entry should have severity');
                assert.ok(entry.source, 'Entry should have source');
                assert.ok(Array.isArray(entry.tags), 'Tags should be an array');
            });

            console.log(`✅ All ${allData.length} entries have required fields`);
        });

        test('Severity values should be valid', async function() {
            this.timeout(120000);

            const result = await dataManager.updateAllVulnerabilityData();
            const allData = [
                ...result.cwe,
                ...result.owasp,
                ...result.cves,
                ...result.javascript
            ];

            const validSeverities = ['critical', 'high', 'medium', 'low'];
            allData.forEach(entry => {
                assert.ok(
                    validSeverities.includes(entry.severity),
                    `Invalid severity: ${entry.severity}`
                );
            });

            console.log('✅ All severity values are valid');
        });

        test('Source values should be valid', async function() {
            this.timeout(120000);

            const result = await dataManager.updateAllVulnerabilityData();
            const allData = [
                ...result.cwe,
                ...result.owasp,
                ...result.cves,
                ...result.javascript
            ];

            const validSources = ['nvd', 'cwe', 'owasp', 'custom'];
            allData.forEach(entry => {
                assert.ok(
                    validSources.includes(entry.source),
                    `Invalid source: ${entry.source}`
                );
            });

            console.log('✅ All source values are valid');
        });
    });
});
