\section{Analysis Modes and Orchestration}
\label{sec:impl-modes}

Code Guardian supports multiple analysis modes that trade off latency, context breadth, and user disruption. Rather than implementing multiple independent pipelines, the system follows a single orchestration pattern: extract code context $\rightarrow$ (optional) retrieve security knowledge $\rightarrow$ run local LLM analysis $\rightarrow$ render diagnostics and optional fixes.

\subsection{Scopes: Function, Selection, File, Workspace}
\label{subsec:impl-scopes}

\textbf{Function scope (real-time).} During editing, Code Guardian analyzes the enclosing function at the cursor position. This reduces prompt size and supports low-latency feedback. A size threshold is applied to skip unusually large functions to avoid blocking the editor.

\textbf{Selection scope.} Developers can explicitly analyze selected code (or the current line if no selection exists). This mode is used for focused investigation and interactive follow-up.

\textbf{File scope.} Full-file analysis runs on demand and produces a complete set of findings for the document. This mode can tolerate higher latency but provides broader context for classification and repair suggestions.

\textbf{Workspace scope.} Workspace scanning analyzes multiple files and aggregates findings into the dashboard. The output is intended for prioritization (which files and categories dominate) rather than line-by-line interaction.

\subsection{LLM-Only vs.\ RAG-Enhanced Execution}
\label{subsec:impl-rag-toggle}

The system offers two operational configurations:
\begin{itemize}
  \item \textbf{LLM-only:} prompt contains the analyzed code plus strict JSON-output constraints. This configuration minimizes overhead and is suitable for real-time use.
  \item \textbf{LLM+RAG:} the prompt is augmented with retrieved CWE/OWASP/CVE knowledge snippets and secure coding guidance. This improves grounding and can reduce false positives or unsupported suggestions, at the cost of additional embedding and retrieval time.
\end{itemize}

RAG can be toggled at runtime through settings and is surfaced via a status-bar indicator in the IDE.

\subsection{Caching and Responsiveness}
\label{subsec:impl-caching}

To reduce repeated inference calls, Code Guardian caches analysis results keyed by (code snippet, model). Under typical editing patterns, small changes frequently return to previously seen states (undo/redo, formatting), making caching effective. Debouncing and caching together aim to keep real-time diagnostics responsive (R6) while maintaining stable behavior across repeated runs (R1).

\subsection{Repair Suggestion Handling}
\label{subsec:impl-repair}

When the model returns a suggested fix, Code Guardian exposes it as a quick fix action. The extension does not auto-apply modifications; instead it requires explicit user confirmation and integrates with the editor undo stack. This design ensures that repair suggestions remain \emph{advisory} and that final responsibility for functional correctness stays with the developer (R4).
