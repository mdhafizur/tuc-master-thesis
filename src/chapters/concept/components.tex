\section{System Components}
\label{sec:system-components}

The Code Guardian prototype is organized into a small set of components that map directly to the requirements from Chapter~\ref{chap:analysis}. The system is implemented as a VS Code extension that (i) extracts an appropriate analysis scope from the editor, (ii) invokes a local LLM for vulnerability analysis, (iii) optionally augments prompts with locally retrieved security knowledge (RAG), and (iv) renders findings and fix suggestions using IDE-native UI elements.

\subsection{Context Extraction Component}
\label{subsec:context-extraction}

The context extraction component determines \emph{which} code is analyzed for a given interaction mode and provides the analyzer with enough metadata to localize findings in the editor.

\textbf{Scopes.} Code Guardian supports multiple scopes with different latency and completeness characteristics:
\begin{itemize}
    \item \textbf{Function scope (real-time)} extracts the innermost function-like block at the cursor position (function declarations, arrow functions, methods, constructors). This is the default for continuous feedback because it keeps the prompt small.
    \item \textbf{File scope (on-demand)} analyzes the full current document and returns a comprehensive set of findings as diagnostics.
    \item \textbf{Selection scope (interactive)} sends a selected region (or current line) into a webview-based analysis view that supports follow-up questions.
    \item \textbf{Workspace scope (batch)} scans all JS/TS files and aggregates results into a security dashboard.
\end{itemize}

\textbf{AST-based function extraction.} Function scope extraction is implemented by parsing the current document with the TypeScript compiler API and selecting the smallest enclosing \texttt{FunctionLikeDeclaration} around the cursor. The extractor returns both the extracted snippet and its start-line offset (0-based) in the original document. This offset enables precise mapping of model-reported line numbers back to VS Code diagnostic ranges.

\textbf{Design rationale.} Function scoping is a practical mechanism to keep latency predictable for real-time use (R6), while the line-offset mapping improves explainability by ensuring that findings point to the correct source locations (R3). Deeper program context (imports, cross-file flows) is not extracted explicitly in the current prototype and is treated as a key future-work direction.

\subsection{Knowledge Retrieval Component (RAG)}
\label{subsec:knowledge-retrieval}

The retrieval component implements Retrieval-Augmented Generation (RAG) to ground LLM reasoning in local security knowledge \cite{lewis2020rag,karpukhin2020dpr}. In Code Guardian, retrieval is implemented by a dedicated \texttt{RAGManager} that maintains a local knowledge base and a persistent vector index.

\textbf{Knowledge base contents.} The knowledge base is populated from a mix of curated and fetched \emph{public} security metadata:
\begin{itemize}
    \item \textbf{CWE-aligned entries} describing common weakness patterns and mitigations \cite{mitreCWE}.
    \item \textbf{OWASP Top 10 guidance} for recurring web vulnerability categories \cite{owaspTop10_2021}.
    \item \textbf{CVE/NVD summaries} retrieved from the NVD API (descriptions and references) \cite{nistNVD,mitreCVE}.
    \item \textbf{JavaScript ecosystem advisories} for dependency and platform-specific risks.
\end{itemize}
Knowledge artifacts are cached on disk and reused across sessions. When network access is unavailable, the system falls back to a small baseline knowledge bundle so retrieval remains functional (with reduced coverage).

\textbf{Indexing and retrieval.} Knowledge entries are chunked using a recursive splitter (chunk size 1000, overlap 200) and embedded locally through an Ollama-served embedding model. Embeddings are stored in a local HNSW vector index \cite{malkov2018hnsw} via LangChain tooling \cite{langchainDocs}. At query time, the top-$k$ most similar chunks are retrieved (default $k=3$) and injected into the prompt as an explicit ``relevant security knowledge'' section.

\textbf{Privacy boundary.} Retrieval and embeddings are executed locally. Optional knowledge refresh operations fetch only public vulnerability metadata; user source code is not transmitted to those endpoints (R5).

\subsection{Vulnerability Detection Component}
\label{subsec:vulnerability-detection}

The vulnerability detection component performs local LLM inference and returns findings in a format suitable for IDE integration.

\textbf{Structured-output analyzer for diagnostics.} For inline diagnostics, Code Guardian enforces a strict JSON-only output contract to reduce ambiguity and parsing failures. Each finding includes:
\begin{itemize}
    \item \textbf{message}: a short description of the issue.
    \item \textbf{startLine}/\textbf{endLine}: 1-based line indices relative to the analyzed snippet.
    \item \textbf{suggestedFix} (optional): a replacement string that can be offered as a quick fix.
\end{itemize}
If no issues are found, the model must return an empty array \texttt{[]}. The analyzer performs defensive parsing by stripping code fences and extracting the first JSON array substring if the model emits additional text.

\textbf{Failure handling and caching.} Transient inference failures (timeouts, local server warm-up) are handled through retry with exponential backoff. To reduce repeated inference on unchanged code, results are cached with an LRU-style strategy keyed by a hash of (code, model), improving responsiveness during iterative edits.

\textbf{Interactive analysis mode.} In addition to the structured diagnostics flow, Code Guardian includes a webview-based analysis view for selected code. This mode uses Markdown-formatted responses and supports follow-up Q\&A. When enabled, the RAG manager can be used to enrich the system prompt and user prompt for this interactive workflow.

\subsection{Repair Generation Component}
\label{subsec:repair-generation}

In the current prototype, repair generation is implemented as an \emph{optional field} in the vulnerability report rather than as a separate autonomous patching system. When the analyzer includes a \texttt{suggestedFix}, the IDE integration layer exposes it as a quick fix action. Applying a fix is always user-initiated and can be reverted via the editor undo stack (R4). The system does not automatically validate functional correctness of repairs; this is treated as a major future improvement area.

\subsection{IDE Integration Layer}
\label{subsec:ide-integration}

The IDE integration layer connects the analysis pipeline to VS Codeâ€™s APIs \cite{vscodeExtensionApi} and determines when analyses run and how results are presented.

\textbf{Triggers.} The extension supports both automatic and manual triggers:
\begin{itemize}
    \item \textbf{Debounced real-time analysis} on document changes (default debounce: 800\,ms) for JavaScript/TypeScript documents.
    \item \textbf{Manual file analysis} via a command palette command, with a size guard to avoid excessively large prompts.
    \item \textbf{Interactive selection analysis} and \textbf{contextual Q\&A} views implemented as WebViews.
    \item \textbf{Workspace scanning} that aggregates results into a dashboard view.
\end{itemize}

\textbf{Presentation.} Findings are rendered as VS Code diagnostics (squiggles, Problems panel, hover tooltips). Suggested repairs are attached to diagnostics and exposed as a quick fix action.

\subsection{Supporting Subsystems}
\label{subsec:supporting-subsystems}

Several additional subsystems are important for usability and reproducibility:
\begin{itemize}
    \item \textbf{Model management} queries available local Ollama models, filters for suitable code models, and supports runtime model switching.
    \item \textbf{Analysis cache} is a bounded LRU cache (100 entries, 30-minute TTL) with user-visible hit/miss statistics.
    \item \textbf{Workspace dashboard} computes a coarse security score using issue density and keyword-based severity heuristics and visualizes the distribution across files.
    \item \textbf{Vulnerability data manager} caches public metadata (e.g., OWASP/CWE/CVE-derived entries) with a time-based expiry to support offline reuse after updates.
\end{itemize}

This section has described the core components that constitute Code Guardian. The next section describes how these components are orchestrated into workflows for real-time feedback, on-demand inspection, and batch scans.
