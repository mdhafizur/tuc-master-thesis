\section{System Architecture and Design}
\label{sec:system-architecture}

This section presents the high-level architecture of Code Guardian using C4-style views (context, containers, and process). The goal is to make the privacy boundary and the main data flows explicit: code stays on-device, local inference is performed through a localhost LLM backend, and retrieval (when enabled) is backed by a local knowledge base and vector index.

\subsection{Context View: System Boundary and External Interactions}
\label{subsec:context-view}

Figure~\ref{fig:c4-context} positions Code Guardian within its operational environment. The primary actor is the developer working inside Visual Studio Code. The system executes in the VS Code extension host and communicates with a local LLM backend (Ollama) running on the same machine \cite{ollamaDocs}.

\textbf{Local assets.} The core local assets are:
\begin{itemize}
    \item \textbf{Workspace source code} (JavaScript/TypeScript) being edited.
    \item \textbf{Local LLM runtime} (Ollama) used for analysis and (optionally) embeddings.
    \item \textbf{Local security knowledge base} and \textbf{vector index} used for retrieval when RAG is enabled \cite{langchainDocs,malkov2018hnsw}.
    \item \textbf{Local caches} for analysis results and vulnerability metadata.
\end{itemize}

\textbf{Optional external data.} Code Guardian may optionally fetch \emph{public vulnerability metadata} to refresh the knowledge base (e.g., CVE records from the NVD API). This traffic does not include user source code and can be disabled by running in offline mode. After a refresh, cached knowledge can be reused without network access. This separation preserves the core privacy goal (no source-code exfiltration) while still allowing the knowledge base to evolve over time.

\begin{figure}[H]
  \centering
  \includegraphics[width=1\linewidth]{images/c4_context.drawio.pdf}
  \caption{Context diagram: Code Guardian runs locally in the VS Code extension host and calls a local LLM backend. A local knowledge base supports retrieval; optional refresh operations may fetch public vulnerability metadata, but source code remains local.}
  \label{fig:c4-context}
\end{figure}

\subsection{Container View: Internal Component Structure}
\label{subsec:container-view}

Figure~\ref{fig:c4-container} summarizes the main internal containers and their responsibilities.

\textbf{VS Code extension host.} The extension is responsible for registering editor triggers, extracting analysis scopes, and rendering results using VS Code diagnostics and WebViews \cite{vscodeExtensionApi}. It provides commands for file analysis, selection analysis, contextual Q\&A, model selection, cache inspection, and workspace scanning.

\textbf{Structured diagnostics pipeline.} For real-time and file-level diagnostics, the extension invokes a JSON-only analyzer that returns a list of issues with line ranges and optional fixes. These results are mapped into VS Code diagnostics and quick fixes. A bounded analysis cache reduces redundant LLM calls for unchanged snippets.

\textbf{Interactive analysis pipeline.} For selection analysis and contextual Q\&A, the extension opens a WebView panel and streams Markdown-formatted responses from the local model. This mode supports conversational follow-up and can incorporate retrieved knowledge when RAG is enabled.

\textbf{RAG manager and data manager.} When enabled, the RAG manager maintains a local knowledge base (serialized entries) and a persistent vector store. A vulnerability data manager refreshes public metadata (CWE-/OWASP-aligned curated entries and optional CVE/advisory sources) and caches results on disk. The vector store is rebuilt or updated based on the knowledge base content.

\begin{sidewaysfigure}
  \centering
  \includegraphics[width=1\linewidth]{images/c4_container.drawio.pdf}
  \caption{Container diagram: The VS Code extension orchestrates context extraction, local LLM analysis, optional retrieval augmentation, and IDE-native rendering. Knowledge and caches are stored locally; optional knowledge refreshes fetch only public metadata.}
  \label{fig:c4-container}
\end{sidewaysfigure}

\subsection{Process View: End-to-End Workflows}
\label{subsec:process-view}

Figure~\ref{fig:bpmn} illustrates the dynamic execution flow for the main workflows.

\textbf{Real-time diagnostics (function scope).}
\begin{enumerate}
    \item A JavaScript/TypeScript document change event occurs in the active editor.
    \item After a debounce interval (800\,ms), the extension extracts the innermost enclosing function at the cursor.
    \item If the extracted scope is within size limits, the local analyzer is invoked and required to return a JSON array of findings.
    \item Findings are parsed defensively, cached, mapped to document ranges, and rendered as diagnostics. Optional \texttt{suggestedFix} strings are surfaced as quick fixes.
\end{enumerate}

\textbf{On-demand file diagnostics.}
\begin{enumerate}
    \item The developer invokes the ``analyze full file'' command.
    \item The full document text is analyzed (subject to a size guard).
    \item Findings are mapped to diagnostics and rendered in the editor.
\end{enumerate}

\textbf{Interactive analysis (selection) and contextual Q\&A.}
\begin{enumerate}
    \item The developer selects code (or context files/folders) and asks a security question.
    \item The extension collects the selected context locally and opens a WebView panel.
    \item The local model streams Markdown-formatted responses; follow-up questions extend the conversation history.
    \item When enabled, retrieved security knowledge can be injected into prompts to ground explanations.
\end{enumerate}

\textbf{Workspace scan and dashboard.}
\begin{enumerate}
    \item The developer starts a workspace scan from the command palette.
    \item The scanner enumerates JS/TS files, excluding dependencies, and skips very large files.
    \item Each file is analyzed locally; issues are aggregated and summarized by severity heuristics and issue density.
    \item Results are shown in a dashboard WebView, which can open files directly and trigger rescans.
\end{enumerate}

\textbf{Privacy considerations in the process view.} Across all workflows, source code is sent only to the local LLM backend on \texttt{localhost}. Optional knowledge refresh operations fetch only public metadata and are cached; disabling refresh yields a fully offline analysis mode.

\begin{sidewaysfigure}
  \centering
  \includegraphics[width=\linewidth]{images/bpmn_process_flow.pdf}
  \caption{Process view: debounced real-time function analysis, on-demand file analysis, interactive analysis/Q\&A, and workspace scanning. The privacy boundary is maintained by keeping code on-device and using local inference.}
  \label{fig:bpmn}
\end{sidewaysfigure}

These architecture views make explicit how Code Guardian operationalizes the conceptual design: modular responsibilities, local inference as the default deployment, optional retrieval grounding, and IDE-native presentation with developer-controlled remediation.
