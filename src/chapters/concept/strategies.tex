\section{Detection Workflows}
\label{sec:detection-strategies}

While the component architecture defines what responsibilities exist in the system, IDE usability depends on how these components are orchestrated in concrete workflows. Code Guardian supports several workflows that trade off latency, context breadth, and output structure. This section describes the main workflows implemented in the prototype and relates them to requirements R1--R6.

\subsection{Real-Time Function-Level Diagnostics}
\label{subsec:inline-detection}

The real-time workflow provides continuous feedback while a developer edits JavaScript/TypeScript code. The key goal is to deliver timely, IDE-native warnings without disrupting flow (R6).

\textbf{Trigger.} The extension listens to document change events for JavaScript and TypeScript documents. Analysis is \emph{debounced} (default: 800\,ms) so the model is not invoked on every keystroke.

\textbf{Scope and guards.} When the debounce fires, Code Guardian extracts the innermost enclosing function at the cursor position and analyzes only that snippet. A size guard skips unusually large functions (default: 2000 characters) to bound worst-case latency and avoid overloading the local model.

\textbf{Structured output for diagnostics.} The analyzer is prompted to return a strict JSON array of issues. Each issue contains a message, a line range, and an optional fix string. The diagnostic adapter maps the snippet-relative, 1-based line numbers to VS Code ranges using the extractorâ€™s line offset and clamps ranges to valid document bounds. This enables stable rendering in the Problems panel, editor squiggles, and hover tooltips (R3).

\textbf{Trade-offs.} Function-level analysis improves responsiveness, but it can miss vulnerabilities whose evidence lies outside the current scope (e.g., validation in a different module). This limitation motivates the on-demand and workspace workflows and is addressed further in the future-work chapter.

\subsection{On-Demand File Diagnostics}
\label{subsec:comprehensive-analysis}

The file workflow provides broader coverage when a developer explicitly requests a deeper scan.

\textbf{Trigger.} A command palette action runs analysis over the full active document.

\textbf{Scope guard.} To avoid generating excessively large prompts, the prototype skips very large files (default: 20{,}000 characters) and warns the user instead.

\textbf{Output.} Findings are surfaced through the same structured diagnostics pipeline as the real-time workflow. This keeps the UI consistent, and it ensures that file scans can be reviewed in the Problems panel and navigated using standard IDE tooling.

\subsection{Interactive Analysis and Follow-up Q\&A}
\label{subsec:interactive-analysis}

Some security questions require richer explanations than a single diagnostic message. Code Guardian therefore includes webview-based interaction modes.

\textbf{Selection analysis view.} The user can analyze a selected region (or the current line) and inspect the response in a dedicated analysis panel. This mode supports follow-up questions and streams Markdown-formatted responses for readability. Because it is user-initiated and not continuously triggered, it can tolerate higher latency than real-time diagnostics.

\textbf{Contextual Q\&A view.} The contextual Q\&A panel allows the user to select files and folders as context and ask security questions about that subset of the workspace. The extension reads the selected files locally and sends their contents only to the local LLM backend, preserving the no-exfiltration objective for source code.

\textbf{RAG usage.} When enabled, the RAG manager can enrich prompts for these interactive workflows by injecting retrieved security knowledge snippets (CWE/OWASP/CVE-derived guidance). Retrieval and embeddings are performed locally; optional knowledge refresh operations fetch only public metadata.

\subsection{Workspace Scan and Security Dashboard}
\label{subsec:workspace-scan}

The workspace workflow supports periodic audits and prioritization across a repository.

\textbf{File discovery and bounds.} The scanner enumerates \texttt{*.js}, \texttt{*.jsx}, \texttt{*.ts}, and \texttt{*.tsx} files in the workspace while excluding dependency folders such as \texttt{node\_modules}. Very large files are skipped (default: $>$500\,KB) to keep runtime bounded.

\textbf{Aggregation and scoring.} Scan results are aggregated into a dashboard WebView. In addition to listing per-file issues, the dashboard computes a coarse security score based on issue density (issues per KLOC) and a keyword-based severity heuristic. This score is intended for prioritization rather than as a formal risk metric.

\textbf{Developer interaction.} The dashboard supports opening affected files directly from the report and rerunning scans. This workflow complements real-time diagnostics by helping developers understand which parts of the codebase concentrate the most findings.

\subsection{Repair Suggestion Workflow}
\label{subsec:repair-workflow}

When the analyzer returns a \texttt{suggestedFix} for an issue, Code Guardian exposes it as a VS Code quick fix. Applying repairs is always user-initiated and integrates with the undo stack. This preserves developer control (R4) and reduces the risk of unintended behavioral changes from automatically applied patches.

\subsection{Workflow Selection in Practice}
\label{subsec:workflow-integration}

In typical use, workflows complement each other:
\begin{enumerate}
    \item Developers receive continuous feedback via debounced, function-level diagnostics while writing code.
    \item Before committing or during review, developers run file scans for broader coverage.
    \item For ambiguous findings or design-level questions, developers use the interactive analysis and contextual Q\&A views to obtain richer explanations and mitigation guidance.
    \item Periodically, workspace scans provide an aggregate view that supports prioritization and remediation planning.
\end{enumerate}

Together, these workflows operationalize the core idea of Code Guardian: privacy-preserving local analysis combined with IDE-native feedback and developer-controlled remediation.
